import unittest
import json
import numpy as np
from PIL import Image
# Adjust the import according to your module's structure
from unittest.mock import patch, MagicMock
# Adjust the import according to your module's structure
from steganography_analyzer import SteganographyAnalyzer


class TestImageEncoding(unittest.TestCase):
    def setUp(self):
        # Create a simple image for testing
        self.image_path = "./image.png"
        self.image = Image.new('RGB', (10, 10), color='white')
        self.image.save(self.image_path)

        # Test data
        self.data = "hello"
        self.binary_data = ''.join(format(ord(char), '08b')
                                   for char in self.data)

        # Image extension and save path
        self.image_extension = "png"
        self.save_image_path = "./test_image.png"

        # Create an instance of SteganographyAnalyzer
        self.analyzer = SteganographyAnalyzer(
            binary=self.binary_data,
            image_extension=self.image_extension,
            image_path=self.image_path,
            save_image_path=self.save_image_path,
            secret_message=self.data
        )

    def test_convert_image(self):
        # Test the convert_image method
        # Assuming convert_image creates or modifies an image file
        self.analyzer.convert_image()
        # Check if the output file exists
        self.assertTrue(os.path.exists(self.analyzer.save_image_path),
                        "The converted image file does not exist.")

    def test_bin_to_utf(self):
        # Test binary to UTF conversion
        utf_string = self.analyzer.bin_to_utf()
        self.assertEqual(
            utf_string, 'H', "The binary to UTF conversion did not return the expected value")

    def test_utf_to_bin(self):
        # Test UTF to binary conversion
        binary_data = self.analyzer.utf_to_bin()
        self.assertIn('01001000', binary_data,
                      "The UTF to binary conversion did not return the expected value")

    def test_decode_image(self):
        # Test decode_image method
        # You'll need to set up a test image with known encoded data to accurately test this
        decoded_message = self.analyzer.decode_image()
        self.assertEqual(decoded_message, 'Your encoded message',
                         "The decoded message did not match the expected output")

    def test_encode_image(self):
        # Convert the data to a binary format if your encode_image function requires so
        binary_data = ''.join(format(ord(char), '08b') for char in self.data)
        binary_data += '00000000'  # Adding an end signal if your encoding process uses one

        # Encode the image
        encoded_image, _ = self.analyzer.encode_image(
            self.image, binary_data, 'png')

        # Verify that the data is encoded correctly
        encoded_array = np.array(encoded_image)
        height, width = encoded_array.shape[:2]
        bit_count = 0

        for i in range(height):
            for j in range(width):
                pixel = encoded_array[i, j]
                for channel in pixel:
                    # Extract the LSB for each color channel
                    lsb = channel & 1
                    expected_bit = int(binary_data[bit_count]) if bit_count < len(
                        binary_data) else 0  # Fallback to 0 if beyond data length
                    self.assertEqual(
                        lsb, expected_bit, f"Mismatch at pixel ({i}, {j}), expected {expected_bit}, got {lsb}")
                    bit_count += 1
                    if bit_count >= len(binary_data):
                        break
                if bit_count >= len(binary_data):
                    break
            if bit_count >= len(binary_data):
                break

    def test_generate_binary(self):
        # Test generate_binary method
        binary_data = self.analyzer.generate_binary()
        self.assertIn('01001000', binary_data,
                      "The generated binary data did not contain the expected value")

    def test_extract_embeded_data(self):
        # Test extract_embeded_data method
        # You'll need to set up a test image with known embedded data to accurately test this
        embedded_data = self.analyzer.extract_embeded_data()
        self.assertEqual(embedded_data, 'Your embedded data',
                         "The extracted data did not match the expected output")

    def test_extract_metadata(self):
        # Test extract_metadata method
        metadata = self.analyzer.extract_metadata()
        # Assertions depend on the expected metadata content
        self.assertIsInstance(
            metadata, dict, "Metadata is not returned in dictionary format.")
        self.assertIn("format", metadata,
                      "Image format is missing in the metadata.")
        self.assertIn("size", metadata,
                      "Image size is missing in the metadata.")

    @patch('subprocess.Popen')
    def test_extract_metadata_with_exiftool(self, mock_subprocess):
        # Mock subprocess.Popen to return a sample JSON output for exiftool
        process_mock = MagicMock()
        attrs = {
            'communicate.return_value': (b'[{"SourceFile": "test.jpg", "EXIF:Make": "TestMake"}]', b''),
            'returncode': 0
        }
        process_mock.configure_mock(**attrs)
        mock_subprocess.return_value = process_mock

        metadata = json.loads(self.analyzer.extract_metadata_with_exiftool())
        self.assertIsInstance(
            metadata, dict, "Metadata is not returned in dictionary format.")
        self.assertIn(
            'SourceFile', metadata[0], "SourceFile key is missing in metadata")
        self.assertEqual(metadata[0]['SourceFile'], 'test.jpg',
                         "SourceFile does not match expected value")
        self.assertEqual(metadata[0]['EXIF:Make'], 'TestMake',
                         "EXIF:Make does not match expected value")

    @patch('subprocess.run')
    def test_extract_metadata_with_identify(self, mock_subprocess):
        # Mock subprocess.run to return a sample output for identify
        mock_subprocess.return_value = MagicMock(
            stdout=b'Image: test.jpg\nFormat: JPEG (Joint Photographic Experts Group JFIF format)\nGeometry: 1920x1080+0+0\n', stderr=b'')

        metadata = self.analyzer.extract_metadata_with_identify()
        self.assertIsInstance(
            metadata, dict, "Metadata is not returned in dictionary format.")
        self.assertIn('Image', metadata, "Image key is missing in metadata")
        self.assertEqual(metadata['Image'], 'test.jpg',
                         "Image does not match expected value")
        self.assertEqual(metadata['Format'], 'JPEG (Joint Photographic Experts Group JFIF format)',
                         "Format does not match expected value")
        self.assertEqual(metadata['Geometry'], '1920x1080+0+0',
                         "Geometry does not match expected value")


if __name__ == '__main__':
    unittest.main()
