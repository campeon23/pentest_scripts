#!/usr/bin/env python

import argparse
import json
import os
import subprocess
import numpy as np
from pillow_heif import register_heif_opener, HeifFile
from PIL import Image
from werkzeug.utils import secure_filename

"""
    Run the script by providing the required arguments in the following format:
    
    Usage:
      ./python keylogger.py -t 60 -e myemail@gmail.com -p mypassword

    Or, if using Vault:

      ./python keylogger.py -t 60 -e myemail@gmail.com -p /path/to/vault/secret
      
    Or, if using an encrypted file:
        
      ./python keylogger.py -t 60 -e myemail@gmail.com -p /path/to/encrypted/file -k encryptionkey
      
    
    This keylogger Python script records all keystrokes on a target system, storing this input data for 
    later retrieval, often used for surveillance or malicious purposes like credential theft.
    
    License:
        MIT License

        Copyright (c) 2023, WildBerry, LLC

        Permission is hereby granted, free of charge, to any person obtaining a copy
        of this software and associated documentation files (the "Software"), to deal
        in the Software without restriction, including without limitation the rights
        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the Software is
        furnished to do so, subject to the following conditions:

        The above copyright notice and this permission notice shall be included in all
        copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        SOFTWARE.
"""

__author__ = "Marco A. Villarruel"
__authors__ = ["Marco A. Villarruel"]
__contacts__ = ["marco.urquieta@proton.me", "marco@wildberry.us"]
__copyright__ = "Copyright 2023, WildBerry, LLC"
__credits__ = ["Marco A. Villarruel"]
__date__ = "2023/06/15"
__deprecated__ = False
__emails__ = ["marco.urquieta@proton.me", "marco@wildberry.us"]
__license__ = "GPLv3"
__maintainer__ = "developer"
__status__ = "Production"
__version__ = "1.0.0"


def logo():
    print("""
          ___    __    __   __  ____  ____  ___   __   _
         / __)  /__\  (  \_/  )(  _ \( ___)/ _ \ (  \_( )
        ( (__  /(__)\ )  ___  ( )___/ )__)( (_) )) (\ ) (
         \___)(__)(__)(__) (__)(__)  (____)\___/ (_) \__)
   _    _  _____  _     ____   _____  ____  _____  _____  _   _
  ( )  ( )(__ __)( )   (  _ \ ( (_) \( ___)( (_) )( (_) )( )_( )
  ) (/\) ( _( )_ ) (__ ) (_) ))  _  ( )__) ) (\ ( ) (\ (  \   /
  (_/  \_)(_____)(____)(____/ (_(_)_/(____)(_) \_)(_) \_)  (_)
    """)


class SteganographyAnalyzer:
    def __init__(self, binary, image_extension, image_path, save_image_path, secret_message):
        self.binary = binary
        self.image_extension = image_extension
        self.image_path = image_path
        self.save_image_path = save_image_path
        self.secret_message = secret_message

    # Register HEIF opener with Pillow
    register_heif_opener()
    count = 0

    def convert_image(self, verbose=False):
        with Image.open(self.image_path) as img:
            img.save(self.save_image_path, format=self.image_extension)
        if verbose:
            print(f"Converted image saved to {self.save_image_path}")

    def reverse_image(self, verbose=False):
        # Reverse the image (flip horizontally)
        _, extension = os.path.splitext(self.image_path)
        image = Image.open(self.image_path, 'r')
        reversed_image = image.transpose(Image.FLIP_LEFT_RIGHT)
        reversed_image.save(self.image_path.replace(
            extension, '_reversed' + extension))
        if verbose:
            print(
                f"Reversed image saved to {self.image_path.replace(extension, '_reversed' + extension)}")

    # Binary to UTF
    def bin_to_utf(self, verbose=False):
        binary_data = json.loads(self.binary)
        unicode_data = ''
        for d in binary_data:
            binary_int = int(d, 2)
            byte_number = binary_int.bit_length() + 7
            binary_array = binary_int.to_bytes(byte_number, "big")
            ascii_text = binary_array.decode("utf-8", 'ignore')
            unicode_data += ascii_text
        if verbose:
            print(unicode_data)
        return unicode_data

    # UTF to Binary
    def utf_to_bin(self, verbose=False):
        binary_data = []
        for char in self.secret_message:
            # Convert each character to its Unicode code point, then to binary with 8 bits
            binary_data.append(format(ord(char), '08b'))
        if verbose:
            print(binary_data)
        return binary_data

    # Binary to ASCII
    def decode_image(self, verbose=False):
        image = Image.open(self.image_path, 'r')
        arr = np.array(image)
        red, green, blue = arr[..., 0], arr[..., 1], arr[..., 2]
        height, width = arr.shape[:2]
        end_signal_byte, data_byte, data = '', '', []

        end_signal = ''.join(format(ord(char), '08b') for char in '<---->')

        for color_channel in [blue, green, red]:
            for i in range(height):
                for j in range(width):
                    data_byte += str(color_channel[i][j] & 1)
                    if len(data_byte) == 8:  # When we have one full byte
                        # Check if end_signal_byte is full
                        if len(end_signal_byte) == len(end_signal):
                            # Remove the first byte
                            end_signal_byte = end_signal_byte[8:]
                        end_signal_byte += data_byte  # Append the new byte to end_signal_byte
                        if end_signal_byte == end_signal:  # Check for end signal
                            print(''.join(data[:-(len(end_signal) - 8)//8]))
                            return ''.join(data[:-(len(end_signal) - 8)//8])
                        # Convert to char and append to data
                        data.append(chr(int(data_byte, 2)))
                        data_byte = ''  # Reset data_byte for the next byte
        result = ''.join(data)
        if verbose:
            print(result)
        return result

    # ASCII to Binary
    def encode_image(self, verbose=False):
        image = Image.open(
            self.image_path).convert('RGB')
        arr = np.array(image)
        red, green, blue = arr[..., 0], arr[..., 1], arr[..., 2]
        height, width = blue.shape

        # Convert data and the end signal to binary using __builtins__.format
        binary_data = ''.join(__builtins__.format(ord(char), '08b')
                              for char in self.secret_message)
        end_signal = ''.join(__builtins__.format(ord(char), '08b')
                             for char in '<---->')

        binary_data += end_signal

        data_index = 0  # Index to keep track of the bit in binary_data to be embedded

        # Loop through the image
        for color_channel in [blue, green, red]:
            for x in range(height):
                for y in range(width):
                    if data_index < len(binary_data):
                        bit = int(binary_data[data_index])
                        color_channel[x, y] = (color_channel[x, y] & ~1) | bit
                        data_index += 1
                    else:
                        break
                if data_index >= len(binary_data):
                    break
            if data_index >= len(binary_data):
                break

        if data_index < len(binary_data):
            raise ValueError(
                "Insufficient space in the image to encode the entire message.")

        # Reconstructing the image
        reconstructed_img = np.stack((red, green, blue), axis=-1)
        img = Image.fromarray(reconstructed_img, 'RGB')

        file_path = secure_filename(self.save_image_path)
        img.save(file_path)
        if verbose:
            print("Image saved to", file_path)
        return img, file_path

    # ASCII to Binary
    def generate_binary(self, verbose=False):
        binary = [format(ord(i), '08b') for i in self.secret_message]
        if verbose:
            print(binary)
        return binary

    # Placeholder function for extracting embedded data
    def extract_embeded_data(self, verbose=False):
        # The implementation of this function would depend on how the data is embedded.
        # This is just a placeholder to illustrate where the data extraction code would go.
        print("Extracting embeded data...")
        # Assuming the data is hidden in the LSB of the red channel of each pixel
        # Initialize a variable to store the extracted bits
        # Load the image from the path
        image = Image.open(self.image_path)

        # Now you can access the width and height attributes
        width, height = image.size
        extracted_bits = ""

        # Iterate over each pixel
        for y in range(height):
            for x in range(width):
                # Get the pixel's value
                pixel = image.getpixel((x, y))

                # Extract the LSB of the red channel
                extracted_bits += str(pixel[0] & 1)

        # Convert the binary data to characters
        data = ""
        for i in range(0, len(extracted_bits), 8):
            byte = extracted_bits[i:i+8]
            if byte:
                data += chr(int(byte, 2))
            if data[-1] == '\0':  # Assuming the message is null-terminated
                break
        if verbose:
            print(data)
        return data

    # Placeholder function for extracting embedded data
    def extract_metadata(self, verbose=False):
        _, file_extension = os.path.splitext(self.image_path)
        metadata = {}

        if file_extension.lower() == '.heic':
            # Process HEIC file metadata using pillow_heif
            register_heif_opener()
            with Image.open(self.image_path) as img:
                metadata = {
                    "format": img.format,
                    "size": img.size,
                    "mode": img.mode,
                    "info": {},
                }

                # Iterate through the info dictionary and decode any bytes objects
                for key, value in img.info.items():
                    # Decode bytes to string, using a standard encoding like utf-8
                    # You might need to adjust the encoding depending on the metadata content
                    if isinstance(value, bytes):
                        metadata['info'][key] = value.decode('utf-8', 'ignore')
                    else:
                        metadata['info'][key] = value
        else:
            # Generic metadata extraction for non-HEIC images
            with Image.open(self.image_path) as image:
                metadata = {
                    "format": image.format,
                    "size": image.size,
                    "mode": image.mode,
                    "info": image.info,
                }

                # Optionally decode bytes objects in the info dictionary
                for key, value in metadata['info'].items():
                    if isinstance(value, bytes):
                        metadata['info'][key] = value.decode('utf-8', 'ignore')

        # Print the metadata in JSON format
        result = json.dumps(metadata, indent=4)
        if verbose:
            print(result)
        return result

    # Placeholder function for extracting metadata using exiftool
    def extract_metadata_with_exiftool(self, verbose=False):
        # Call exiftool to extract metadata
        process = subprocess.Popen(
            ['exiftool', '-json', '-G', self.image_path], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = process.communicate()

        # Decode the output and load it into a Python dictionary
        if out:
            metadata = json.loads(out.decode('utf-8'))
            result = json.dumps(metadata, indent=4)
            if verbose:
                print(result)
            return result
        else:
            print("No metadata found or exiftool error:", err.decode('utf-8'))

    # Placeholder function for extracting metadata using identify
    def extract_metadata_with_identify(self, verbose=False):
        # Execute the `identify -verbose` command
        result = subprocess.run(['identify', '-verbose', self.image_path],
                                stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

        # Check for errors
        if result.stderr:
            print("Error:", result.stderr)
            return

        # Process the output
        metadata = {}
        current_section = None
        for line in result.stdout.split('\n'):
            line = line.strip()
            if not line:
                continue  # Skip empty lines

            # Check if the line is a section header
            if line.endswith(':'):
                current_section = line[:-1]
                metadata[current_section] = {}
            elif current_section:
                # Parse the line as a key-value pair
                key, value = line.split(':', 1)
                key = key.strip()
                value = value.strip()
                metadata[current_section][key] = value

        result = json.dumps(metadata, indent=4)
        if verbose:
            print(result)
        return result


def main():
    logo()

    parser = argparse.ArgumentParser(
        description="Embed and extract data from images.")
    parser.add_argument("-a", "--extract-metadata", dest="extract_metadata",
                        action='store_true', help="Extract standard metadata")
    parser.add_argument("-b", "--bin-to-utf", dest="bin_to_utf",
                        action='store_true', help="Convert binary to UTF")
    parser.add_argument("-c", "--convert-image", dest="convert_image", action='store_true',
                        help="Convert image format A to format B")
    parser.add_argument("-d", "--decode-image", dest="decode_image",
                        action='store_true', help="Extract message from image")
    parser.add_argument("-e", "--encode-image", dest="encode_image",
                        action='store_true', help="Embed message to image")
    parser.add_argument("-g", "--generate-binary", dest="generate_binary",
                        action='store_true', help="Convert message to binary")
    parser.add_argument("-i", "--image", dest="image_path",
                        type=str, help="Location of image", required=False)
    parser.add_argument("-l", "--exiftool", dest="exiftool",
                        action='store_true', help="Extract metadata with exiftool")
    parser.add_argument("-m", "--message", dest="secret_message",
                        help="Message to encode into the image", required=False)
    parser.add_argument("-n", "--binary", dest="binary",
                        help="Binary to convert to string.", required=False)
    parser.add_argument("-r", "--reverse-image", dest="reverse_image",
                        action='store_true', help="Reverse image pixels")
    parser.add_argument("-s", "--save-image-path", dest="save_image_path",
                        type=str, help="Save image to specific location", required=False)
    parser.add_argument("-u", "--utf-to-bin", dest="utf_to_bin",
                        action='store_true', help="Convert UTF to binary")
    parser.add_argument("-v", "--verbose", dest="verbose",
                        action='store_true', help="Print output if verbose enabled.")
    parser.add_argument("-x", "--extension", dest="image_extension",
                        help="Format of image to save", required=False)
    parser.add_argument("-y", "--identify", dest="identify",
                        action='store_true', help="Extract metadata with identify")
    parser.add_argument("-z", "--extract-embeded-data", dest="extract_embeded_data",
                        action='store_true', help="Extract embedded data")

    args = parser.parse_args()

    analyzer = SteganographyAnalyzer(
        binary=args.binary,
        image_extension=args.image_extension,
        image_path=args.image_path,
        save_image_path=args.save_image_path,
        secret_message=args.secret_message,
    )  # Create an instance of the class

    if args.convert_image:
        if not args.image_path:
            parser.error("--convert-image requires --image-path.")
        if not args.save_image_path:
            parser.error("--convert-image requires --save-image-path.")
        if not args.image_extension:
            parser.error("--convert-image requires --image-extension.")
        analyzer.convert_image(verbose=args.verbose)

    if args.reverse_image:
        if not args.image_path:
            parser.error("--reverse-image requires --image-path.")
        analyzer.reverse_image(verbose=args.verbose)

    if args.bin_to_utf:
        if not args.binary:
            parser.error("--bin-to-utf requires --binary.")
        analyzer.bin_to_utf(verbose=args.verbose)

    if args.utf_to_bin:
        if not args.secret_message:
            parser.error("--utf-to-bin requires --message.")
        analyzer.utf_to_bin(verbose=args.verbose)

    if args.decode_image:
        if not args.image_path:
            parser.error("--decode-image requires --image-path.")

        _, extension = os.path.splitext(args.image_path)
        if extension == ".heic":
            parser.error(
                "--decode-image does not support HEIC format. Convert the image to PNG format using --convert-image first.")
        analyzer.decode_image(verbose=args.verbose)

    if args.encode_image:
        if not args.image_path:
            parser.error("--encode-image requires --image-path.")
        if not args.save_image_path:
            parser.error("--encode-image requires --save-image-path.")
        if not args.secret_message:
            parser.error("--encode-image requires --message.")
        _, extension = os.path.splitext(args.image_path)
        if extension == ".heic":
            parser.error(
                "--decode-image does not support HEIC format. Convert the image to PNG format using --convert-image first.")
        analyzer.encode_image(verbose=args.verbose)

    if args.generate_binary:
        if not args.secret_message:
            parser.error("--generate-binary requires --message.")
        analyzer.generate_binary(verbose=args.verbose)

    if args.identify:
        if not args.image_path:
            parser.error("--identify requires --image-path.")
        analyzer.extract_metadata_with_identify(verbose=args.verbose)

    if args.exiftool:
        if not args.image_path:
            parser.error("--exiftool requires --image-path.")
        analyzer.extract_metadata_with_exiftool(verbose=args.verbose)

    if args.extract_metadata:
        if not args.image_path:
            parser.error("--extract-metadata requires --image-path.")
        analyzer.extract_metadata(verbose=args.verbose)

    if args.extract_embeded_data:
        if not args.image_path:
            parser.error("--extract-embeded-data requires --image-path.")
        _, extension = os.path.splitext(args.image_path)
        if extension == ".heic":
            parser.error(
                "--extract-embeded-data requires does not support HEIC format. Convert the image to PNG format using --convert-image first.")
        analyzer.extract_embeded_data(verbose=args.verbose)


if __name__ == "__main__":
    main()
