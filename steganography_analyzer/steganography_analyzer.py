#!/usr/bin/env python

import argparse
import json
import os
import subprocess
import numpy as np
from pillow_heif import register_heif_opener
from PIL import Image
from werkzeug.utils import secure_filename

"""
    Usage Description for SteganographyAnalyzer
    The SteganographyAnalyzer is a versatile Python script designed 
    for embedding and extracting hidden messages within image files, 
    as well as performing various image and metadata manipulations. 
    It offers a range of functionalities that can be accessed via 
    command-line arguments to facilitate steganography analysis and 
    image data extraction.

    Basic Usage:
    To embed a message into an image:
    
    python steganography_analyzer.py -e -i <input_image> -m 'Your secret message' -s <output_image> -v
    -e: Encode or embed a message into the image.
    -i: Specifies the input image file.
    -m: The message you wish to embed within the image.
    -s: The output image file where the encoded image will be saved.
    -v: Enables verbose output, providing detailed process information.
    Example:

    python steganography_analyzer.py -e -i IMG_6884.png -m 'This is 
    amazing. I bet you cannot find the message v2!' -s IMG_6884_encoded.png -v
    This command embeds the message "This is amazing. I bet you cannot 
    find the message v2!" into IMG_6884.png and saves the result as 
    IMG_6884_encoded.png.

    Decoding a Message:
    To extract a hidden message from an image:

    python steganography_analyzer.py -d -i <encoded_image> -v
    -d: Decode or extract the message from the image.
    -i: Specifies the encoded image file from which to extract the message.
    Example:

    python steganography_analyzer.py -d -i IMG_6884_encoded.png -v
    This command extracts the hidden message from IMG_6884_encoded.png.

    Extracting Metadata:
    To extract metadata from an image:

    python steganography_analyzer.py -l -i <image> -v
    -l: Extract metadata from the image using exiftool.
    -i: Specifies the image file from which to extract metadata.
    Example:

    python steganography_analyzer.py -l -i IMG_6884_reversed.heic -v
    This command extracts metadata from IMG_6884_reversed.heic and displays it 
    in a readable JSON format.

    Image Conversion and Manipulation:
    Convert an image to a different format or manipulate its pixels:

    python steganography_analyzer.py -c -i <input_image> -x <format> -s <output_image> -v
    -c: Convert the image to a different format or manipulate it.
    -x: Specifies the target image format.
    -s: The output image file after conversion.
    The SteganographyAnalyzer script offers a powerful toolkit for digital image 
    steganography and analysis, providing users with the ability to embed secret 
    messages, extract hidden data, analyze image metadata, and perform various image 
    manipulations through a straightforward command-line interface.
        
    License:
        MIT License

        Copyright (c) 2023, WildBerry, LLC

        Permission is hereby granted, free of charge, to any person obtaining a copy
        of this software and associated documentation files (the "Software"), to deal
        in the Software without restriction, including without limitation the rights
        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the Software is
        furnished to do so, subject to the following conditions:

        The above copyright notice and this permission notice shall be included in all
        copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        SOFTWARE.
"""

__author__ = "Marco A. Villarruel"
__authors__ = ["Marco A. Villarruel"]
__contacts__ = ["marco.urquieta@proton.me", "marco@wildberry.us"]
__copyright__ = "Copyright 2023, WildBerry, LLC"
__credits__ = ["Marco A. Villarruel"]
__date__ = "2023/06/15"
__deprecated__ = False
__emails__ = ["marco.urquieta@proton.me", "marco@wildberry.us"]
__license__ = "GPLv3"
__maintainer__ = "developer"
__status__ = "Production"
__version__ = "1.0.0"


def logo():
    print("""
          ___    __    __   __  ____  ____  ___   __   _
         / __)  /__\  (  \_/  )(  _ \( ___)/ _ \ (  \_( )
        ( (__  /(__)\ )  ___  ( )___/ )__)( (_) )) (\ ) (
         \___)(__)(__)(__) (__)(__)  (____)\___/ (_) \__)
   _    _  _____  _     ____   _____  ____  _____  _____  _   _
  ( )  ( )(__ __)( )   (  _ \ ( (_) \( ___)( (_) )( (_) )( )_( )
  ) (/\) ( _( )_ ) (__ ) (_) ))  _  ( )__) ) (\ ( ) (\ (  \   /
  (_/  \_)(_____)(____)(____/ (_(_)_/(____)(_) \_)(_) \_)  (_)
    """)


class SteganographyAnalyzer:
    def __init__(self, binary, image_path, save_image_path, secret_message, secret_message_file):
        self.binary = binary
        self.image_path = image_path
        self.save_image_path = save_image_path
        self.secret_message = secret_message
        self.secret_message_file = secret_message_file

    # Register HEIF opener with Pillow
    register_heif_opener()
    count = 0

    def validate_path(self, input_path, base_directory=None):
        if base_directory is None:
            base_directory = os.getcwd()  # Get the current working directory

        # Normalize the paths to remove any relative path components
        normalized_base_dir = os.path.normpath(base_directory)
        normalized_input_path = os.path.normpath(
            os.path.join(base_directory, input_path))

        # Check if the input path is within the base directory
        if not normalized_input_path.startswith(normalized_base_dir + os.sep):
            raise ValueError("Invalid path: Path traversal detected.")

        # Check for other suspicious characters or sequences
        if '..' in input_path or '%' in input_path or '\x00' in input_path:
            raise ValueError("Invalid path: Suspicious characters detected.")

        print(f"Path '{input_path}' is validated and safe.")
        return normalized_input_path

    def convert_image(self, verbose=False):
        _, extension = os.path.splitext(self.save_image_path)
        with Image.open(self.image_path) as img:
            img.save(self.save_image_path, format=extension[1:].upper())
        if verbose:
            print(f"Converted image saved to {self.save_image_path}")

    def reverse_image(self, verbose=False):
        # Reverse the image (flip horizontally)
        _, extension = os.path.splitext(self.image_path)
        image = Image.open(self.image_path, 'r')
        reversed_image = image.transpose(Image.FLIP_LEFT_RIGHT)
        reversed_image.save(self.image_path.replace(
            extension, '_reversed' + extension))
        if verbose:
            print(
                f"Reversed image saved to {self.image_path.replace(extension, '_reversed' + extension)}")

    # Binary to UTF
    def bin_to_utf(self, verbose=False):
        binary_data = json.loads(self.binary)
        unicode_data = ''
        for d in binary_data:
            binary_int = int(d, 2)
            byte_number = binary_int.bit_length() + 7
            binary_array = binary_int.to_bytes(byte_number, "big")
            ascii_text = binary_array.decode("utf-8", 'ignore')
            unicode_data += ascii_text
        if verbose:
            print(unicode_data)
        return unicode_data

    # UTF to Binary
    def utf_to_bin(self, verbose=False):
        binary_data = []
        for char in self.secret_message:
            # Convert each character to its Unicode code point, then to binary with 8 bits
            binary_data.append(format(ord(char), '08b'))
        if verbose:
            print(binary_data)
        return binary_data

    # Binary to ASCII
    def decode_image(self, verbose=False):
        image = Image.open(self.image_path, 'r')
        arr = np.array(image)
        red, green, blue = arr[..., 0], arr[..., 1], arr[..., 2]
        height, width = arr.shape[:2]
        end_signal_byte, data_byte, data = '', '', []

        end_signal = ''.join(format(ord(char), '08b') for char in '<---->')

        for color_channel in [blue, green, red]:
            for i in range(height):
                for j in range(width):
                    data_byte += str(color_channel[i][j] & 1)
                    if len(data_byte) == 8:  # When we have one full byte
                        # Check if end_signal_byte is full
                        if len(end_signal_byte) == len(end_signal):
                            # Remove the first byte
                            end_signal_byte = end_signal_byte[8:]
                        end_signal_byte += data_byte  # Append the new byte to end_signal_byte
                        if end_signal_byte == end_signal:  # Check for end signal
                            decoded_data = ''.join(
                                data[:-(len(end_signal) - 8)//8])
                            print(decoded_data)
                            if self.secret_message_file:
                                with open('decoded_message_test1.txt', 'wb') as f:
                                    f.write(
                                        decoded_data.encode('latin-1'))  # Write the decoded data to a file
                            return decoded_data
                        # Convert to char and append to data
                        data.append(chr(int(data_byte, 2)))
                        data_byte = ''  # Reset data_byte for the next byte
        result = ''.join(data)
        if verbose:
            print(result)

        return result

    # ASCII to Binary
    def encode_image(self, verbose=False):
        try:
            if self.secret_message_file:
                secret_message_filepath = self.validate_path(
                    self.secret_message_file)

                with open(secret_message_filepath, 'rb') as f:
                    secret_message = f.read()

                # print("Secret message 1:", secret_message.decode(
                #     'latin-1').encode('latin-1'))

                # with open('secret_message_saved_again.txt', 'wb') as f:
                #     f.write(secret_message)
            else:
                secret_message = self.secret_message

        except ValueError as e:
            print(f"Path validation error: {e}")

        image = Image.open(
            self.image_path).convert('RGB')
        arr = np.array(image)
        red, green, blue = arr[..., 0], arr[..., 1], arr[..., 2]
        height, width = blue.shape

        # print("Secret message:", secret_message)

        # Convert data and the end signal to binary using __builtins__.format
        if self.secret_message_file:
            binary_data = ''.join(format(byte, '08b')
                                  for byte in secret_message)
        if self.secret_message:
            binary_data = ''.join(__builtins__.format(ord(char), '08b')
                                  for char in secret_message)
        end_signal = ''.join(__builtins__.format(ord(char), '08b')
                             for char in '<---->')

        binary_data += end_signal

        data_index = 0  # Index to keep track of the bit in binary_data to be embedded

        # Loop through the image
        for color_channel in [blue, green, red]:
            for x in range(height):
                for y in range(width):
                    if data_index < len(binary_data):
                        bit = int(binary_data[data_index])
                        color_channel[x, y] = (color_channel[x, y] & ~1) | bit
                        data_index += 1
                    else:
                        break
                if data_index >= len(binary_data):
                    break
            if data_index >= len(binary_data):
                break

        if data_index < len(binary_data):
            raise ValueError(
                "Insufficient space in the image to encode the entire message.")

        # Reconstructing the image
        reconstructed_img = np.stack((red, green, blue), axis=-1)
        img = Image.fromarray(reconstructed_img, 'RGB')

        file_path = secure_filename(self.save_image_path)
        img.save(file_path)
        if verbose:
            print("Image saved to", file_path)
        return img, file_path

    # ASCII to Binary
    def generate_binary(self, verbose=False):
        binary = [format(ord(i), '08b') for i in self.secret_message]
        if verbose:
            print(binary)
        return binary

    # Placeholder function for extracting embedded data
    def extract_embeded_data(self, verbose=False):
        # The implementation of this function would depend on how the data is embedded.
        # This is just a placeholder to illustrate where the data extraction code would go.
        print("Extracting embeded data...")
        # Assuming the data is hidden in the LSB of the red channel of each pixel
        # Initialize a variable to store the extracted bits
        # Load the image from the path
        image = Image.open(self.image_path)

        # Now you can access the width and height attributes
        width, height = image.size
        extracted_bits = ""

        # Iterate over each pixel
        for y in range(height):
            for x in range(width):
                # Get the pixel's value
                pixel = image.getpixel((x, y))

                # Extract the LSB of the red channel
                extracted_bits += str(pixel[0] & 1)

        # Convert the binary data to characters
        data = ""
        for i in range(0, len(extracted_bits), 8):
            byte = extracted_bits[i:i+8]
            if byte:
                data += chr(int(byte, 2))
            if data[-1] == '\0':  # Assuming the message is null-terminated
                break
        if verbose:
            print(data)
        return data

    # Placeholder function for extracting embedded data
    def extract_metadata(self, verbose=False):
        _, file_extension = os.path.splitext(self.image_path)
        metadata = {}

        if file_extension.lower() == '.heic':
            # Process HEIC file metadata using pillow_heif
            register_heif_opener()
            with Image.open(self.image_path) as img:
                metadata = {
                    "format": img.format,
                    "size": img.size,
                    "mode": img.mode,
                    "info": {},
                }

                # Iterate through the info dictionary and decode any bytes objects
                for key, value in img.info.items():
                    # Decode bytes to string, using a standard encoding like utf-8
                    # You might need to adjust the encoding depending on the metadata content
                    if isinstance(value, bytes):
                        metadata['info'][key] = value.decode('utf-8', 'ignore')
                    else:
                        metadata['info'][key] = value
        else:
            # Generic metadata extraction for non-HEIC images
            with Image.open(self.image_path) as image:
                metadata = {
                    "format": image.format,
                    "size": image.size,
                    "mode": image.mode,
                    "info": image.info,
                }

                # Optionally decode bytes objects in the info dictionary
                for key, value in metadata['info'].items():
                    if isinstance(value, bytes):
                        metadata['info'][key] = value.decode('utf-8', 'ignore')

        # Print the metadata in JSON format
        result = json.dumps(metadata, indent=4)
        if verbose:
            print(result)
        return result

    # Placeholder function for extracting metadata using exiftool
    def extract_metadata_with_exiftool(self, verbose=False):
        # Call exiftool to extract metadata
        process = subprocess.Popen(
            ['exiftool', '-json', '-G', self.image_path], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = process.communicate()

        # Decode the output and load it into a Python dictionary
        if out:
            metadata = json.loads(out.decode('utf-8'))
            result = json.dumps(metadata, indent=4)
            if verbose:
                print(result)
            return result
        else:
            print("No metadata found or exiftool error:", err.decode('utf-8'))

    # Placeholder function for extracting metadata using identify
    def extract_metadata_with_identify(self, verbose=False):
        # Execute the `identify -verbose` command
        result = subprocess.run(['identify', '-verbose', self.image_path],
                                stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

        # Check for errors
        if result.stderr:
            print("Error:", result.stderr)
            return

        # Process the output
        metadata = {}
        current_section = None
        for line in result.stdout.split('\n'):
            line = line.strip()
            if not line:
                continue  # Skip empty lines

            # Check if the line is a section header
            if line.endswith(':'):
                current_section = line[:-1]
                metadata[current_section] = {}
            elif current_section:
                # Parse the line as a key-value pair
                key, value = line.split(':', 1)
                key = key.strip()
                value = value.strip()
                metadata[current_section][key] = value

        result = json.dumps(metadata, indent=4)
        if verbose:
            print(result)
        return result


def main():
    logo()

    parser = argparse.ArgumentParser(
        description="Embed and extract data from images.")
    parser.add_argument("-a", "--extract-metadata", dest="extract_metadata",
                        action='store_true', help="Extract standard metadata")
    parser.add_argument("-b", "--bin-to-utf", dest="bin_to_utf",
                        action='store_true', help="Convert binary to UTF")
    parser.add_argument("-c", "--convert-image", dest="convert_image", action='store_true',
                        help="Convert image format A to format B")
    parser.add_argument("-d", "--decode-image", dest="decode_image",
                        action='store_true', help="Extract message from image")
    parser.add_argument("-e", "--encode-image", dest="encode_image",
                        action='store_true', help="Embed message to image")
    parser.add_argument("-f", "--message-file", dest="secret_message_file",
                        type=str, help="Location of the file containing the message.", required=False)
    parser.add_argument("-g", "--generate-binary", dest="generate_binary",
                        action='store_true', help="Convert message to binary")
    parser.add_argument("-i", "--image", dest="image_path",
                        type=str, help="Location of image", required=False)
    parser.add_argument("-l", "--exiftool", dest="exiftool",
                        action='store_true', help="Extract metadata with exiftool")
    parser.add_argument("-m", "--message", dest="secret_message",
                        help="Message to encode into the image", required=False)
    parser.add_argument("-n", "--binary", dest="binary",
                        help="Binary to convert to string.", required=False)
    parser.add_argument("-r", "--reverse-image", dest="reverse_image",
                        action='store_true', help="Reverse image pixels")
    parser.add_argument("-s", "--save-image-path", dest="save_image_path",
                        type=str, help="Save image to specific location", required=False)
    parser.add_argument("-u", "--utf-to-bin", dest="utf_to_bin",
                        action='store_true', help="Convert UTF to binary")
    parser.add_argument("-v", "--verbose", dest="verbose",
                        action='store_true', help="Print output if verbose enabled.")
    parser.add_argument("-y", "--identify", dest="identify",
                        action='store_true', help="Extract metadata with identify")
    parser.add_argument("-z", "--extract-embeded-data", dest="extract_embeded_data",
                        action='store_true', help="Extract embedded data")

    args = parser.parse_args()

    analyzer = SteganographyAnalyzer(
        binary=args.binary,
        image_path=args.image_path,
        save_image_path=args.save_image_path,
        secret_message=args.secret_message,
        secret_message_file=args.secret_message_file
    )  # Create an instance of the class

    if args.convert_image:
        if not args.image_path:
            parser.error("--convert-image requires --image-path.")
        if not args.save_image_path:
            parser.error("--convert-image requires --save-image-path.")
        analyzer.convert_image(verbose=args.verbose)

    if args.reverse_image:
        if not args.image_path:
            parser.error("--reverse-image requires --image-path.")
        analyzer.reverse_image(verbose=args.verbose)

    if args.bin_to_utf:
        if not args.binary:
            parser.error("--bin-to-utf requires --binary.")
        analyzer.bin_to_utf(verbose=args.verbose)

    if args.utf_to_bin:
        if not args.secret_message:
            parser.error("--utf-to-bin requires --message.")
        analyzer.utf_to_bin(verbose=args.verbose)

    if args.decode_image:
        if not args.image_path:
            parser.error("--decode-image requires --image-path.")

        _, extension = os.path.splitext(args.image_path)
        if extension == ".heic":
            parser.error(
                "--decode-image does not support HEIC format. Convert the image to PNG format using --convert-image first.")
        analyzer.decode_image(verbose=args.verbose)

    if args.encode_image:
        if not args.image_path:
            parser.error("--encode-image requires --image-path.")
        if not args.save_image_path:
            parser.error("--encode-image requires --save-image-path.")
        if not args.secret_message and not args.secret_message_file:
            parser.error(
                "--encode-image requires either --message or --message-file.")
        _, extension = os.path.splitext(args.image_path)
        if extension == ".heic":
            parser.error(
                "--decode-image does not support HEIC format. Convert the image to PNG format using --convert-image first.")
        analyzer.encode_image(verbose=args.verbose)

    if args.generate_binary:
        if not args.secret_message:
            parser.error("--generate-binary requires --message.")
        analyzer.generate_binary(verbose=args.verbose)

    if args.identify:
        if not args.image_path:
            parser.error("--identify requires --image-path.")
        analyzer.extract_metadata_with_identify(verbose=args.verbose)

    if args.exiftool:
        if not args.image_path:
            parser.error("--exiftool requires --image-path.")
        analyzer.extract_metadata_with_exiftool(verbose=args.verbose)

    if args.extract_metadata:
        if not args.image_path:
            parser.error("--extract-metadata requires --image-path.")
        analyzer.extract_metadata(verbose=args.verbose)

    if args.extract_embeded_data:
        if not args.image_path:
            parser.error("--extract-embeded-data requires --image-path.")
        _, extension = os.path.splitext(args.image_path)
        if extension == ".heic":
            parser.error(
                "--extract-embeded-data requires does not support HEIC format. Convert the image to PNG format using --convert-image first.")
        analyzer.extract_embeded_data(verbose=args.verbose)


if __name__ == "__main__":
    main()
