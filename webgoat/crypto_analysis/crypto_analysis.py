#!/usr/bin/env python

# Import required libraries
# Standard Python libraries
import os
import importlib.util
import base64
import hashlib
import re
import argparse
import time
import urllib.parse

# Additional packages
from OpenSSL import crypto
from Crypto.Cipher import AES
from Crypto.Hash import SHA256
from Crypto.PublicKey import RSA
from Crypto.Signature import PKCS1_v1_5

# Cryptography packages
import cryptography.hazmat.backends as crypto_backends
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization

# Custom exception to handle missing packages

'''
        To run the script, you can use the following command from your terminal:

        python script.py -c 'your_cookie' -b 'your_base64_string' -x 'your_xor_string' \
            -p './path_to_password_file' -m 'md5_hash' -s 'sha256_hash' \
            -r './path_to_rsa_key' -e 'encrypted_message' -k 'secret_key'

'''

def import_module_from_path(path_to_module):
    spec = importlib.util.spec_from_file_location("module_name", path_to_module)
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)
    return module

class MissingPackagesError(Exception):
    pass


# Verify all required packages are installed
try:
    # The packages are being imported above, if an ImportError is raised, the except block will be executed
    pass
except ImportError:
    raise MissingPackagesError(
        "Missing required Python packages. Install with: 'pip install <package_name>'")


class CryptoBase:
    """A base class for cryptographic operations."""

    def __init__(self, file_passwords_path: str):
        """Initialize the class with path to passwords file."""
        self.file_passwords_path = file_passwords_path

    def encode_base64(self, input_string: str) -> str:
        """Encode a string in Base64."""
        encoded_string = base64.b64encode(
            input_string.encode("utf-8")).decode("utf-8")
        return encoded_string

    def decode_base64(self, encoded_base64_string: str) -> str:
        """Decode a Base64 encoded string."""
        decoded_string = base64.b64decode(
            encoded_base64_string.encode("utf-8")).decode("utf-8")
        return decoded_string

    def xor_strings(self, str1: str, str2: str) -> str:
        """Create an XOR sum between two strings."""
        decoded_password = ''.join(chr(ord(a) ^ ord(b))
                                   for a, b in zip(str1, str2))
        return decoded_password

    def decode_xor(self, encoded_xor_string: str) -> str:
        """Decode an XOR encoded string."""
        xor_encoded_string = encoded_xor_string.replace('{xor}', '')
        value1 = self.decode_base64(xor_encoded_string)
        value2 = '_' * len(value1)
        return self.xor_strings(value1, value2)

    def is_md5(self, hashed_string: str) -> bool:
        """Validate if a string is MD5 hashed."""
        is_md5 = re.findall(
            r'(?i)(?<![a-z0-9])[a-f0-9]{32}(?![a-z0-9])', hashed_string)
        return bool(is_md5)

    def is_sha256(self, hashed_string: str) -> bool:
        """Validate if a string is SHA256 hashed."""
        is_sha256 = re.findall(
            r'(?i)(?<![a-z0-9])[a-f0-9]{64}(?![a-z0-9])', hashed_string)
        return bool(is_sha256)

    def crack_hash(self, hashed_string: str) -> str:
        """Attempt to crack a given hash using a dictionary attack."""

        start_time = time.time()
        guess = " "
        result = "no solution found"

        with open(self.file_passwords_path, 'r') as file_passwords:
            if self.is_md5(hashed_string):
                # For each password in file, generate MD5 hash and compare against the provided hash
                result = self._match_hash(
                    file_passwords, hashed_string, hashlib.md5)

            elif self.is_sha256(hashed_string):
                # For each password in file, generate SHA256 hash and compare against the provided hash
                result = self._match_hash(
                    file_passwords, hashed_string, hashlib.sha256)

            else:
                result = "Invalid hash."

        # Calculate runtime
        end_time = time.time()
        total_time = end_time - start_time
        print(
            f"Total runtime was -- {total_time} seconds and the result was: {result}")

        return result

    def _match_hash(self, passwords, hashed_string: str, hash_func) -> str:
        """Helper function to match hashed string with hash of passwords from a file."""
        for password in passwords:
            password = password.strip()  # Remove newline character
            hashed_password = hash_func(password.encode()).hexdigest()
            if hashed_password == hashed_string.lower():
                return password

        return "no solution found"  # If no match is found, return this message

    def save_public_key(self, pk, cert_path: str) -> None:
        """Save a public key to a file."""

        if isinstance(pk, crypto_backends.openssl.rsa._RSAPublicKey):
            pem = pk.public_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PublicFormat.SubjectPublicKeyInfo
            )

        elif isinstance(pk, crypto_backends.openssl.rsa._RSAPrivateKey):
            pem = pk.public_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.TraditionalOpenSSL,
                encryption_algorithm=serialization.NoEncryption()
            )

        else:
            raise ValueError(
                "Provided key is neither a public nor a private RSA key.")

        with open(cert_path, 'wb') as pem_out:
            pem_out.write(pem)

    def extract_public_key(self, private_cert_path: str, cert_path: str) -> None:
        """Extract a public key from a private certificate and save it to a file."""

        with open(private_cert_path, 'rb') as key_file:
            private_key = serialization.load_pem_private_key(
                key_file.read(),
                password=None,
                backend=default_backend()
            )
            public_key = private_key.public_key()
            print("Public key: ", public_key)

            self.save_public_key(public_key, cert_path)

    def get_rsa_cert(self, cert_path: str):
        """Load an RSA certificate from a file."""

        with open(cert_path, 'rb') as cert_file:
            key_data = cert_file.read()

        key = RSA.importKey(key_data)

        return key

    def get_key_and_iv(self, password: str, salt: bytes, klen=32, ilen=16, msgdgst='md5'):
        """
        Derive the key and the IV from the given password and salt.
        Source: http://stackoverflow.com/questions/13907841/implement-openssl-aes-encryption-in-python

        :param password: The password to use as the seed.
        :param salt: The salt.
        :param klen: The key length.
        :param ilen: The initialization vector length.
        :param msgdgst: The message digest algorithm to use.
        """
        try:
            # Get the appropriate message digest function from hashlib
            msg_digest_func = getattr(hashlib, msgdgst)

            password = password.encode('ascii', 'ignore')  # convert to ASCII

            maxlen = klen + ilen
            key_iv = msg_digest_func(password + salt).digest()
            tmp = [key_iv]
            while len(key_iv) < maxlen:
                tmp_key_iv = msg_digest_func(
                    tmp[-1] + password + salt).digest()
                tmp.append(tmp_key_iv)
                key_iv += tmp_key_iv  # append the last byte
            key = key_iv[:klen]
            iv = key_iv[klen:klen+ilen]
            return key, iv

        except UnicodeDecodeError:
            print("Error: Unicode decode error in get_key_and_iv.")
            return None, None

    def decrypt_message(self, ciphertext: bytes, password: str) -> bytes:
        """
        Decrypts a message using AES-256-CBC, compatible with OpenSSL decryption.
        Equivalent to openssl command:
        openssl enc -d -aes-256-cbc -base64 -salt -pass pass:<password> -in ciphertext

        :param ciphertext: Ciphertext to be decrypted.
        :param password: Password for decryption.
        :return: Decrypted data.
        """

        # Ensure that the ciphertext is bytes, not str
        if isinstance(ciphertext, str):
            ciphertext = ciphertext.encode('utf-8')

        # Split the ciphertext into lines, ignoring empty lines and comments
        filtered = b'\n'.join(
            line for line in ciphertext.split(b'\n')
            if line.strip() and not line.strip().startswith(b'#')
        )

        # Base64 decode
        raw = base64.b64decode(filtered)
        assert raw[:8] == b'Salted__'
        salt = raw[8:16]  # Extract the salt

        # Create the key and iv
        key, iv = self.get_key_and_iv(password, salt, msgdgst='sha256')
        if key is None:
            return None

        # Extract the original ciphertext
        ciphertext = raw[16:]

        # Decrypt
        cipher = AES.new(key, AES.MODE_CBC, iv)
        padded_plaintext = cipher.decrypt(ciphertext)

        # Unpad the plaintext
        plaintext = padded_plaintext[:-padded_plaintext[-1]]
        return plaintext

    def get_modulus(self, cert_path: str) -> str:
        """Returns the modulus of an RSA certificate in hexadecimal format."""

        key = self.get_rsa_cert(cert_path)
        return hex(key.n)[2:]

    def validate_signature(self, pub_cert_path: str, modulus: str, signature: bytes) -> None:
        """
        Validates the signature of a message against a public key.

        :param pub_cert_path: Path to the public certificate.
        :param modulus: The modulus of the public key.
        :param signature: The signature to validate.
        """

        public_key = self.get_rsa_cert(pub_cert_path)

        # Create a SHA-256 digest of the modulus
        digest = SHA256.new()
        digest.update(modulus.encode('utf-8'))

        try:
            PKCS1_v1_5.new(public_key).verify(digest, signature)
            print("The signature is valid.")
        except (ValueError, TypeError):
            print("The signature is not valid.")

    def get_signature(self, cert_path: str, modulus: str) -> str:
        """
        Signs the given modulus using the private key from the certificate file.

        :param cert_path: Path to the certificate file containing the private key.
        :param modulus: The modulus to be signed.
        :return: Base64-encoded signature.
        """

        with open(cert_path, 'rb') as cert_file:
            private_key_pem = cert_file.read()

        private_key = crypto.load_privatekey(
            crypto.FILETYPE_PEM, private_key_pem)

        # Sign the modulus using SHA-256
        signature = crypto.sign(private_key, modulus.encode('utf-8'), "sha256")

        # Encode the signature in base64
        encoded_signature = base64.b64encode(signature)

        return encoded_signature.decode('utf-8')


def main(args):
    """
    Main function for script execution.
    It initiates a session with a given URL and executes different cryptographic operations.
    """
    
    # Get the path to the directory above the current one
    parent_dir = os.path.abspath(os.path.join(os.getcwd(), os.pardir))
    # Build the full path to the module
    module_path = os.path.join(parent_dir, "../", "secrets_retreiver", "secrets_retreiver.py")
    # Use the function
    http_requests = import_module_from_path(module_path)
    session = http_requests.HTTPRequests()
    
    # Initialize session and crypto objects with provided arguments
    session_hijack = session(args.attack_url, args.cookie)
    crypto_basis = CryptoBase(args.passwords_path)

    # Base64 Encoding Exercise
    user, password = crypto_basis.decode_64(args.base64_string).split(":")
    payload = f"answer_user={urllib.parse.quote(user)}&answer_pwd={urllib.parse.quote(password)}"
    session_hijack.post_payload_lesson_challenge(
        "crypto/encoding/basic-auth", payload)

    # XOR Encoding Exercise
    passcode = crypto_basis.decode_xor(args.xor_string)
    payload = f"answer_pwd1={urllib.parse.quote(passcode)}"
    session_hijack.post_payload_lesson_challenge(
        "crypto/encoding/xor", payload)

    # Hash Cracking Exercise
    pwd1 = crypto_basis.crack_hash(args.md5_hash)
    pwd2 = crypto_basis.crack_hash(args.sha256_hash)
    payload = f"answer_pwd1={urllib.parse.quote(pwd1)}&answer_pwd2={urllib.parse.quote(pwd2)}"
    session_hijack.post_payload_lesson_challenge("crypto/hashing", payload)

    # RSA Signatures Exercise
    modulus = crypto_basis.get_modulus(args.certificate)
    signature = crypto_basis.get_signature(args.certificate, modulus)
    payload = f"modulus={urllib.parse.quote(modulus)}&signature={urllib.parse.quote(signature)}"
    session_hijack.post_payload_lesson_challenge(
        "crypto/signing/verify", payload)

    # Encryption/Decryption Exercise
    message = crypto_basis.decrypt_message(args.encrypted_message, args.secret)
    payload = f"secretText={urllib.parse.quote(message)}&secretFileName=default_secret"
    session_hijack.post_payload_lesson_challenge(
        'crypto/secure/defaults', payload)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description='Script for practicing different cryptographic operations.')

    parser.add_argument('-u', '--atack_url', help='WebGoat attack URL', required=False,
                        default="http://www.webgoat.local:8080/WebGoat/")
    parser.add_argument('-c', '--cookie', help='WebGoat cookie string', required=False,
                        default="aFExueZqT-vYm7WAAdDql1sP5iY047to_Kl_BCrZ")
    parser.add_argument('-b', '--base64', dest='base64_string', required=False,
                        help='Base64 encoded string', default="dGV1c2VyOjEyMzQ1Ng==")
    parser.add_argument('-x', '--xor', dest='xor_string', required=False,
                        help='XOR encoded string', default="{xor}Oz4rPj0+LDovPiwsKDAtOw==")
    parser.add_argument('-p', '--passwords', dest='passwords_path', required=False,
                        help='Path to password file', default="./10k-most-common.txt")
    parser.add_argument('-m', '--md5', dest='md5_hash', required=False,
                        help='MD5 salted hash', default="E10ADC3949BA59ABBE56E057F20F883E")
    parser.add_argument('-s', '--sha256', dest='sha256_hash', help='SHA256 salted hash',
                        default="5E884898DA28047151D0E56F8DC6292773603D0D6AABBDD62A11EF721D1542D8")
    parser.add_argument('-r', '--rsa', dest='certificate', required=False,
                        help='Path to RSA private key', default='./private_key.pem')
    parser.add_argument('-e', '--encrypted', dest='encrypted_message', required=False,
                        help='Encrypted message', default="U2FsdGVkX199jgh5oANElFdtCxIEvdEvciLi+v+5loE+VCuy6Ii0b+5byb5DXp32RPmT02Ek1pf55ctQN+DHbwCPiVRfFQamDmbHBUpD7as=")
    parser.add_argument('-k', '--secret', help='Secret key for decryption', required=False,
                        default="ThisIsMySecretPassw0rdF0rY0u")

    args = parser.parse_args()
    main(args)
