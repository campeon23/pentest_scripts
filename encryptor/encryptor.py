import argparse
import getpass
import gnupg
import os
import re
# from pathlib import Path
# from cryptography.exceptions import CryptographyException
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa, padding, ec
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend

"""
    Encryptor Usage Description
    The Encryptor tool provides a versatile solution for encrypting and decrypting messages using RSA/Elliptic Curve and GPG. Here's how you can leverage the Encryptor tool based on the provided arguments and examples:

    Encrypting a Message with RSA/Elliptic Curve:

    python encryptor.py -e -p public_key_8192.pem -m "This is a test" -s test_encrypted_8192.txt
    -e or --encrypt-message: Activates the encryption mode using RSA or Elliptic Curve.
    -p or --public-key: Specifies the public key file (public_key_8192.pem) for encryption.
    -m or --message: The message to be encrypted ("This is a test").
    -s or --encrypted-file: Specifies the file to save the encrypted message (test_encrypted_8192.txt).
    
    Decrypting a Message with RSA/Elliptic Curve:

    python encryptor.py -d -n decoded_message_test1.txt -r private_key_8192.pem -v
    -d or --decrypt-message: Initiates decryption using RSA or Elliptic Curve.
    -n or --encrypted-file: Specifies the file where the decrypted message will be saved (decoded_message_test1.txt).
    -r or --private-key: Designates the private key file (private_key_8192.pem) for decryption.
    -v or --verbose: Enables verbose output for detailed process information.
   
    Decrypting a Message with GPG:

    python encryptor.py -f -n test_encrypted_pgp.txt -i some@email.com -v
    -f or --decrypt-message-gpg: Activates decryption mode using GPG.
    -n or --encrypted-file: Specifies the output file for the decrypted message (test_encrypted_pgp.txt).
    -i or --gpg-identifier: Identifies the GPG key (here, an email associated with the GPG key: mvilla@ditcons.com).
    -v or --verbose: Enables verbose output.
    
    Encrypting a Message with GPG:

    python encryptor.py -g -i mvilla@ditcons.com -m "This is a test"
    -g or --encrypt-message-gpg: Activates encryption mode using GPG.
    -i or --gpg-identifier: Specifies the GPG key identifier (here, an email).
    -m or --message: The message to be encrypted ("This is a test").
    
    By utilizing these commands, users can easily encrypt and decrypt messages for secure communication, leveraging 
    the robustness of RSA/Elliptic Curve and GPG encryption methodologies. Whether you're handling sensitive data or 
    requiring secure message exchange, the Encryptor tool provides the necessary functionalities to meet your 
    encryption needs.
            
    License:
        MIT License

        Copyright (c) 2023, WildBerry, LLC

        Permission is hereby granted, free of charge, to any person obtaining a copy
        of this software and associated documentation files (the "Software"), to deal
        in the Software without restriction, including without limitation the rights
        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the Software is
        furnished to do so, subject to the following conditions:

        The above copyright notice and this permission notice shall be included in all
        copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        SOFTWARE.
"""

__author__ = "Marco A. Villarruel"
__authors__ = ["Marco A. Villarruel"]
__contacts__ = ["marco.urquieta@proton.me", "marco@wildberry.us"]
__copyright__ = "Copyright 2023, WildBerry, LLC"
__credits__ = ["Marco A. Villarruel"]
__date__ = "2023/06/15"
__deprecated__ = False
__emails__ = ["marco.urquieta@proton.me", "marco@wildberry.us"]
__license__ = "GPLv3"
__maintainer__ = "developer"
__status__ = "Production"
__version__ = "1.0.0"


def logo():
    print("""
          ___    __    __   __  ____  ____  ___   __   _
         / __)  /__\  (  \_/  )(  _ \( ___)/ _ \ (  \_( )
        ( (__  /(__)\ )  ___  ( )___/ )__)( (_) )) (\ ) (
         \___)(__)(__)(__) (__)(__)  (____)\___/ (_) \__)
   _    _  _____  _     ____   _____  ____  _____  _____  _   _
  ( )  ( )(__ __)( )   (  _ \ ( (_) \( ___)( (_) )( (_) )( )_( )
  ) (/\) ( _( )_ ) (__ ) (_) ))  _  ( )__) ) (\ ( ) (\ (  \   /
  (_/  \_)(_____)(____)(____/ (_(_)_/(____)(_) \_)(_) \_)  (_)
    """)


class Encryptor:
    def __init__(self, public_key, private_key, message, encrypted_filepath, gpg_identifier=None, gpg_homedir='~/.gnupg', cs_gpg_options=['--pinentry-mode loopback']):
        self.public_key = public_key
        self.private_key = private_key
        self.message = message
        self.encrypted_filepath = encrypted_filepath
        self.gpg_identifier = gpg_identifier
        # Initialize the GPG object with the specified home directory
        self.gpg = gnupg.GPG(homedir=gpg_homedir, options=cs_gpg_options)
        self.gpg.encoding = 'utf-8'

    def validate_path(self, input_path, base_directory=None):
        if base_directory is None:
            base_directory = os.getcwd()  # Get the current working directory

        # Normalize the paths to remove any relative path components
        normalized_base_dir = os.path.normpath(base_directory)
        normalized_input_path = os.path.normpath(
            os.path.join(base_directory, input_path))

        # Check if the input path is within the base directory
        if not normalized_input_path.startswith(normalized_base_dir + os.sep):
            raise ValueError("Invalid path: Path traversal detected.")

        # Check for other suspicious characters or sequences
        if '..' in input_path or '%' in input_path or '\x00' in input_path:
            raise ValueError("Invalid path: Suspicious characters detected.")

        print(f"Path '{input_path}' is validated and safe.")
        return normalized_input_path

    def load_key(self, key_path):
        with open(key_path, "rb") as key_file:
            key_data = key_file.read()

        # Try to load a PEM-encoded public key
        try:
            key = serialization.load_pem_public_key(
                key_data, backend=default_backend())
            key_type = "public"
        except ValueError:
            # Try to load a PEM-encoded private key
            try:
                key = serialization.load_pem_private_key(
                    key_data, password=None, backend=default_backend())
                key_type = "private"
            except ValueError:
                # Try to load a DER-encoded key
                try:
                    key = serialization.load_der_private_key(
                        key_data, password=None, backend=default_backend())
                    key_type = "private" if isinstance(key, rsa.RSAPrivateKey) or isinstance(
                        key, ec.EllipticCurvePrivateKey) else "public"
                except ValueError as e:
                    raise ValueError(
                        f"Unable to determine the key type or load the key: {e}")

        print(
            f"{key_type.capitalize()} key loaded successfully: {key}, Type: {type(key)}")
        return key, key_type

    def get_key_id_by_email(self, identifier):
        public_keys = self.gpg.list_keys()

        for key in public_keys:
            for uid in key['uids']:
                if identifier in uid:
                    # Or 'fingerprint' for the full fingerprint
                    return key['keyid']

        return None

    def validate_identifier(self, identifier):
        # Regular expression for validating an Email
        print("Identifier: ", identifier)
        email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        # Regular expression for validating a GPG Key ID (8 or 16 hexadecimal characters)
        key_id_regex = r'^[A-Fa-f0-9]{40}$'

        if re.match(email_regex, identifier):
            print("Valid email: ", identifier)
            return self.get_key_id_by_email(identifier)
        elif re.match(key_id_regex, identifier):
            print("Valid key ID: ", identifier)
            # Return the key ID if it matches the regex pattern
            return identifier
        else:
            raise ValueError(
                "Invalid GPG key identifier. Please provide a valid email or key ID.")

    def encrypt_message(self, message_encoding='utf-8', rsa_padding_hash=None, symmetric_algorithm=algorithms.AES, symmetric_mode=modes.CFB, verbose=False):
        """
        Encrypt a message using the provided public key.

        :param public_key: The public key in PEM format or loaded PublicKey object.
        :param message: The plaintext message to encrypt.
        :param message_encoding: Encoding of the input message (default: 'utf-8').
        :param rsa_padding_hash: Hash algorithm for RSA OAEP padding (default: SHA-256).
        :param symmetric_algorithm: Symmetric encryption algorithm class (default: AES).
        :param symmetric_mode: Symmetric encryption mode class (default: CFB).
        :return: Encrypted message.
        """
        try:
            if self.encrypted_filepath:
                output = self.validate_path(self.encrypted_filepath)
            else:
                output = None
            # Proceed with using safe_path for file operations
        except ValueError as e:
            print(f"Path validation error: {e}")

        # Validate and load the public key
        try:
            if rsa_padding_hash is None:
                rsa_padding_hash = hashes.SHA256()
            if isinstance(self.public_key, str):
                public_key, _ = self.load_key(self.public_key)
            else:
                raise ValueError("Public key must be a PEM encoded string")

        # Some cryptography operation
        except ValueError as e:
            # Handle a value error
            print(f"Value error: {str(e)}")
        except TypeError as e:
            # Handle a type error
            print(f"Type error: {str(e)}")

        # Check the key type (RSA or Elliptic Curve)
        if isinstance(public_key, rsa.RSAPublicKey):
            # RSA encryption with configurable padding and hash
            try:
                ciphertext = public_key.encrypt(
                    self.message.encode(message_encoding),
                    padding.OAEP(
                        mgf=padding.MGF1(algorithm=rsa_padding_hash),
                        algorithm=rsa_padding_hash,
                        label=None
                    )
                )

            # Some cryptography operation
            except ValueError as e:
                # Handle a value error
                print(f"Value error: {str(e)}")
            except TypeError as e:
                # Handle a type error
                print(f"Type error: {str(e)}")
        elif isinstance(public_key, ec.EllipticCurvePublicKey):
            # Elliptic Curve encryption using ECDH and configurable symmetric encryption
            try:
                private_key = ec.generate_private_key(public_key.curve)
                shared_secret = private_key.exchange(
                    ec.ECDH(), public_key)

                derived_key = HKDF(
                    algorithm=hashes.SHA256(),
                    length=32,
                    salt=None,
                    info=b'handshake data',
                ).derive(shared_secret)

                iv = os.urandom(16)  # Initialization vector
                cipher = Cipher(symmetric_algorithm(
                    derived_key), symmetric_mode(iv))
                encryptor = cipher.encryptor()
                ciphertext = iv + \
                    encryptor.update(self.message.encode(
                        message_encoding)) + encryptor.finalize()

            # Some cryptography operation
            except ValueError as e:
                # Handle a value error
                print(f"Value error: {str(e)}")
            except TypeError as e:
                # Handle a type error
                print(f"Type error: {str(e)}")
        else:
            raise ValueError("Unsupported key type")

        if output:
            with open(output, 'wb') as f:
                f.write(ciphertext)

        if verbose:
            # Print the encrypted message
            print(f"Encrypted message: {ciphertext.decode('utf-8')}")
        return ciphertext

    def encrypt_message_gpg(self, verbose=False):
        """
        Encrypt a message using GPG with the provided public key identifier.

        :param keyserver: The key server from which to fetch the public key.
        :param verbose: Print output if verbose enabled.
        :return: Encrypted message as a string.
        """
        try:
            if self.encrypted_filepath:
                output = self.validate_path(self.encrypted_filepath)
            else:
                output = None
            # Proceed with using safe_path for file operations
        except ValueError as e:
            print(f"Path validation error: {e}")

        # Encrypt the message
        encrypted_data = self.gpg.encrypt(
            self.message, self.validate_identifier(self.gpg_identifier), armor=True, always_trust=True, symmetric=False)

        # Check if the encryption was successful
        if not encrypted_data.ok:
            raise RuntimeError(f"Encryption failed: {encrypted_data.status}")

        if output:
            with open(output, 'wb') as f:
                f.write(encrypted_data.data)

        # Optionally print the encrypted message
        if verbose:
            print(f"Encrypted message: {encrypted_data}")
        return str(encrypted_data)

    # , symmetric_algorithm=algorithms.AES, symmetric_mode=modes.CFB, verbose=False):
    def decrypt_message(self, message_encoding='utf-8', rsa_padding_hash=None, verbose=False):
        """
        Decrypt a message using the provided private key.

        :param encrypted_data: The encrypted message to decrypt.
        :param private_key: The private key in PEM format or loaded PrivateKey object for decryption.
        :param message_encoding: Encoding of the output message (default: 'utf-8').
        :param rsa_padding_hash: Hash algorithm for RSA OAEP padding (default: SHA-256).
        :param symmetric_algorithm: Symmetric encryption algorithm class (default: AES).
        :param symmetric_mode: Symmetric encryption mode class (default: CFB).
        :return: Decrypted message.
        """
        try:
            if self.encrypted_filepath:
                encrypted_filepath = self.validate_path(
                    self.encrypted_filepath)

                with open(encrypted_filepath, 'rb') as f:
                    encrypted_data = f.read()

        except ValueError as e:
            print(f"Path validation error: {e}")

        # Validate and load the private key
        try:
            if rsa_padding_hash is None:
                rsa_padding_hash = hashes.SHA256()

            # Load the private key
            if isinstance(self.private_key, str):
                private_key, key_type = self.load_key(self.private_key)
                if key_type != "private":
                    raise ValueError("The provided key is not a private key.")
            else:
                private_key = self.private_key

            if not isinstance(private_key, (rsa.RSAPrivateKey, ec.EllipticCurvePrivateKey)):
                raise ValueError(
                    "Private key must be an RSA/EC private key object")

        except Exception as e:
            print(f"Error loading private key: {str(e)}")
            raise

        # Decrypt the message
        plaintext = None
        try:
            if isinstance(private_key, rsa.RSAPrivateKey):
                plaintext = private_key.decrypt(
                    encrypted_data,
                    padding.OAEP(
                        mgf=padding.MGF1(algorithm=rsa_padding_hash),
                        algorithm=rsa_padding_hash,
                        label=None
                    )
                )
            elif isinstance(private_key, ec.EllipticCurvePrivateKey):
                raise NotImplementedError(
                    "EC decryption requires a shared secret and is not directly implemented")
            else:
                raise ValueError("Unsupported private key type for decryption")

            # Decode the plaintext message
            if plaintext is not None:
                decrypted_data = plaintext.decode(message_encoding)
            else:
                raise ValueError(
                    "Decryption failed, plaintext could not be obtained.")

        except Exception as e:
            print(f"Error during decryption: {str(e)}")
            raise

        if verbose:
            print(f"Decrypted message: {decrypted_data}")

        return decrypted_data

    def decrypt_message_gpg(self, verbose=False):
        """
        Decrypt a message using GPG with the private key corresponding to the public key identifier.

        :param encrypted_data: The encrypted message to decrypt as a string.
        :param verbose: Print output if verbose enabled.
        :return: Decrypted message as a string.
        """
        try:
            if self.encrypted_filepath:
                encrypted_filepath = self.validate_path(
                    self.encrypted_filepath)

                with open(encrypted_filepath, 'rb') as f:
                    encrypted_data = f.read()

        except ValueError as e:
            print(f"Path validation error: {e}")

        # Prompt for the passphrase
        passphrase = getpass.getpass("Enter passphrase for GPG private key: ")

        # Ensure the input is in the correct format (bytes)
        if isinstance(encrypted_data, str):
            encrypted_data = encrypted_data.encode('utf-8')

        if isinstance(encrypted_data, gnupg._parsers.Crypt):
            encrypted_data = encrypted_data.data

        # Decrypt the message using the passphrase
        decrypted_data = self.gpg.decrypt(
            encrypted_data, passphrase=passphrase, always_trust=True)

       # Check if the decryption was successful
        if not decrypted_data.ok:
            error_msg = f"Decryption failed: {decrypted_data.status}"
            # Provide a generic message if specifics are not accessible
            error_msg += " - Additional error details are unavailable."
            raise RuntimeError(error_msg)

        # Optionally print the decrypted message
        if verbose:
            print(f"Decrypted message: {decrypted_data.data.decode('utf-8')}")

        return str(decrypted_data.data.decode('utf-8'))


def main():
    logo()

    parser = argparse.ArgumentParser(
        description="Embed and extract data from images.")
    parser.add_argument("-d", "--decrypt-message", dest="decrypt_message",
                        action='store_true', help="Decrypt the message using RSA or Elliptic Curve.")
    parser.add_argument("-e", "--encrypt-message", dest="encrypt_message",
                        action='store_true', help="Encrypt the message using RSA or Elliptic Curve.")
    parser.add_argument("-f", "--decrypt-message-gpg", dest="decrypt_message_gpg",
                        action='store_true', help="Decrypt the message using GPG.")
    parser.add_argument("-g", "--encrypt-message-gpg", dest="encrypt_message_gpg",
                        action='store_true', help="Encrypt the message using GPG.")
    parser.add_argument("-i", "--gpg-identifier", dest="gpg_identifier",
                        help="Public key identifier for GPG encryption to encrypt messages", required=False)
    parser.add_argument("-m", "--message", dest="message",
                        help="Message to be encrypted.", required=False)
    parser.add_argument("-n", "--encrypted-file", dest="encrypted_filepath",
                        help="Save output to a file", required=False)
    parser.add_argument("-p", "--public-key", dest="public_key",
                        help="Key to encrypt messages", required=False)
    parser.add_argument("-r", "--private-key", dest="private_key",
                        help="Key to decrypt messages", required=False)
    parser.add_argument("-v", "--verbose", dest="verbose",
                        action='store_true', help="Print output if verbose enabled.")

    args = parser.parse_args()

    encryptor = Encryptor(
        message=args.message,
        public_key=args.public_key,
        private_key=args.private_key,
        gpg_identifier=args.gpg_identifier,
        encrypted_filepath=args.encrypted_filepath,
    )  # Create an instance of the class

    if args.encrypt_message:
        if not args.message:
            parser.error("--encrypt-message requires --message.")
        if not args.public_key:
            parser.error("--encrypt-message requires --public-key.")
        encryptor.encrypt_message(verbose=args.verbose)

    if args.decrypt_message:
        if not args.private_key:
            parser.error("--decrypt-message requires --private-key.")
        if not args.encrypted_filepath:
            parser.error("--decrypt-message requires --encrypted-file.")
        encryptor.decrypt_message(verbose=args.verbose)

    if args.encrypt_message_gpg:
        if not args.message:
            parser.error("--encrypt-message-gpg requires --message.")
        if not args.gpg_identifier:
            parser.error("--encrypt-message-gpg requires --gpg-identifier.")
        encryptor.encrypt_message_gpg(verbose=args.verbose)

    if args.decrypt_message_gpg:
        if not args.gpg_identifier:
            parser.error("--decrypt-message-gpg requires --gpg-identifier.")
        if not args.encrypted_filepath:
            parser.error("--decrypt-message requires --encrypted-file.")
        encryptor.decrypt_message_gpg(verbose=args.verbose)


if __name__ == "__main__":
    main()
