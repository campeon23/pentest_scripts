#!/usr/bin/env python

import subprocess
import smtplib
import re
import argparse
import hvac
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad

"""
    This script can be executed using the command line:
    
    Usage:
      ./python script.py -c "sc query type= service state= all" -s "WiFi router config" -smtp "smtp-relay.gmail.com" -p 587

    If you want to use a password from an encrypted file:

      ./python script.py -c "sc query type= service state= all" -s "WiFi router config" -smtp "smtp-relay.gmail.com" -p 587 -f "encrypted_password.txt" -k "my_encryption_key"
    
    License:
        MIT License

        Copyright (c) 2023 Marco A. Villarruel

        Permission is hereby granted, free of charge, to any person obtaining a copy
        of this software and associated documentation files (the "Software"), to deal
        in the Software without restriction, including without limitation the rights
        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the Software is
        furnished to do so, subject to the following conditions:

        The above copyright notice and this permission notice shall be included in all
        copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        SOFTWARE.
"""

__author__      = "Marco A. Villarruel"
__authors__     = ["Marco A. Villarruel"]
__contact__     = "marco.urquieta@proton.me"
__copyright__   = "Copyright 2013, WildBerry"
__credits__     = ["Marco A. Villarruel"]
__date__        = "2023/06/15"
__deprecated__  = False
__email__       =  "marco.urquieta@proton.me"
__license__     = "GPLv3"
__maintainer__  = "developer"
__status__      = "Production"
__version__     = "1.0.0"

def logo():
    print("""
        ___    __    __   __  ____  ____  ___   __   _
       / __)  /__\  (  \_/  )(  _ \( ___)/ _ \ (  \_( )
      ( (__  /(__)\ )  ___  ( )___/ )__)( (_) )) (\ ) (
       \___)(__)(__)(__) (__)(__)  (____)\___/ (_) \__)
 _    _  _____  _     ____   _____  ____  _____  _____  _   _
( )  ( )(__ __)( )   (  _ \ ( (_) \( ___)( (_) )( (_) )( )_( )  
) (/\) ( _( )_ ) (__ ) (_) ))  _  ( )__) ) (\ ( ) (\ (  \   /
(_/  \_)(_____)(____)(____/ (_(_)_/(____)(_) \_)(_) \_)  (_)
        """)
    
def get_password_from_vault(vault_addr, vault_token, secret_path, secret_key):
    """
    Fetch a secret from HashiCorp Vault.

    Parameters:
    vault_addr (str): The URL of the HashiCorp Vault instance.
    vault_token (str): A valid Vault token.
    secret_path (str): The path of the secret in the Vault.
    secret_key (str): The key of the secret to fetch.

    Returns:
    secret (str): The requested secret.
    """

    client = hvac.Client(url=vault_addr, token=vault_token)

    if not client.is_authenticated():
        print("Error: Invalid Vault token.")
        return None

    read_response = client.secrets.kv.v2.read_secret_version(path=secret_path)

    if secret_key in read_response["data"]["data"]:
        return read_response["data"]["data"][secret_key]
    else:
        print(f"Error: {secret_key} not found in the secret.")
        return None


def get_password_from_encrypted_file(file_path, key):
    """
    Fetch a password from an encrypted file.

    Parameters:
    file_path (str): The path to the encrypted file.
    key (bytes): The decryption key. It should be 16, 24 or 32 bytes long.

    Returns:
    password (str): The decrypted password.
    """

    cipher = AES.new(key, AES.MODE_ECB)

    with open(file_path, 'rb') as f:
        ciphertext = f.read()

    plaintext = unpad(cipher.decrypt(ciphertext), AES.block_size)

    return plaintext.decode('utf-8')


def send_mail(email, password, message, smtp_server, smtp_port):
    msg = MIMEMultipart()
    msg['From'] = email
    msg['To'] = email
    msg['Subject'] = 'WiFi router config'
    msg.attach(MIMEText(message, _subtype='plain', _charset='UTF-8'))

    server = smtplib.SMTP(smtp_server, smtp_port)
    server.starttls()
    server.login(email, password)
    server.sendmail(email, email, msg.as_string())
    server.quit()


def main(email, command, subject, smtp_server, smtp_port, vault_path=None, pass_file=None, key=None):
    logo()
    result = subprocess.run(command, shell=True,
                            stdout=subprocess.PIPE).stdout.decode('us-ascii')
    services = re.findall('(?:SERVICE_NAME:* )(.*)', result)

    for service in services:
        service = service.replace('\r', '')
        command = 'sc query ' + service
        current_result = subprocess.check_output(
            command, shell=True).decode('us-ascii')
        service_status = re.search('(?:STATE\s*: \d\s)(.*)', current_result)
        result = result + service + ': ' + service_status.group(1) + '\r\n'

    if vault_path:
        password = get_password_from_vault(vault_path)
    elif pass_file and key:
        password = get_password_from_encrypted_file(pass_file, key)
    else:
        raise Exception(
            "Either vault_path or (pass_file and key) should be provided")

    send_mail(email, password, result, smtp_server, smtp_port)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description='Service status monitoring script.')
    parser.add_argument('-e', '--email', type=str,
                        help='Email address', required=True)
    parser.add_argument('-c', '--command', type=str,
                        help='Command to run', required=True)
    parser.add_argument('-s', '--subject', type=str,
                        help='Email subject', required=True)
    parser.add_argument('-S', '--smtp-server', type=str,
                        help='SMTP server', required=True)
    parser.add_argument('-P', '--smtp-port', type=int,
                        help='SMTP port', required=True)
    parser.add_argument('-v', '--vault-path', type=str,
                        help='Path to the vault secret')
    parser.add_argument('-f', '--pass-file', type=str,
                        help='Path to the encrypted password file')
    parser.add_argument('-k', '--key', type=str, help='Encryption key')

    args = parser.parse_args()

    main(args.email, args.command, args.subject, args.smtp_server,
         args.smtp_port, args.vault_path, args.pass_file, args.key)
